<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=512, user-scalable=0, viewport-fit=contain"/>
    </head>
    <body>
        <style>
            .controls-container{
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                margin:auto;
                max-width: 400px;
                gap:16px;
                margin-top:35px;
            }
            .controls-container>div{
                flex-basis: calc(33.33% - 16px);
                height:100px;
                
                align-content: center;
                text-align: center;
                border-radius: 8px;
                
            }
            .controls-container>.key{
                outline: 2px solid black;
                background: grey;
                user-select: none;
                cursor: pointer;
            }
            body{
                min-width: 512px;
                background:#333;
            }
        </style>
        <canvas id="game" width="512" height="512" style="transform:scale(0.5);">

        </canvas>
        <canvas id="camera" width="512" height="512">

        </canvas>
        <div class="controls-container" id="touch_input_container">
            <div></div><div class="key" data-key="w">W</div><div></div>
            <div class="key" data-key="a">A</div>
            <div class="key" data-key="s">S</div>
            <div class="key" data-key="d">D</div>
        </div>
        <div id="map_edit_container" style="display:none;"><label for="map_code">Map layout code <input name="map_code" id="map_code" value=""/></label><button id="load_map_btn">load</button></div>
        <br><button id="map_edit_btn">map edit mode</button>

        <script>
            const canvasCamera = document.getElementById('camera');
            /** @type {CanvasRenderingContext2D} */
            const ctxCamera = canvasCamera.getContext('2d');

            const canvas = document.getElementById('game');
            /** @type {CanvasRenderingContext2D} */
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "black";
            ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
            var gridSize = 16;
            var resolution = 128;
            var halfRes = 64;
            var keyInputs = {
                w:false,
                s:false,
                a:false,
                d:false,
                m:false,
                Shift:false,
                Space:false
            };
            var strawb;
            var hoof;
            var player;
            var rayIntersections;
            var spriteList = [];
            var spriteRenders = [];
            var menuOpen = true;

            var MAP_EDIT_MODE = false;

            var strawbCount = 0;
            var sceneGoal = 0;
            var sceneScore = 0;
            var userInterface;
            var splashScreen;
            var keyCount = {};
            var levelCounter = 0;
            var dataSquares = [];
            var lastMouseAction = {
                button:-1,
                gridX:0,
                gridY:0
            };

            var level_1 = "/////////( (  #//( (  #//( (  #//( (  #//( (  #//(    #//( (  #//( (  #//( (  #//( (  #//( (  #//( (  #////.////. (    /. (    /. (    /. (    /. (    /. (    /. (    /.      /.      /.      /.      /.      /.      /.      /.      /.      /.      /////////&-/$8.*&,#0%";
            var level_2 = '////////(  $   !(  $   !(" $\'( !("&$ ( !("&$ ( !(" $$( !(" $$( !). \',( !)"&$$/#/)"&$$  !)" $   !(" $  "!(" $$ "!)"&\'//.!)"&$   !).     !)(  #/.!((&$" "!((&$. "!((    "!((  " "!/.\',//#+("" ( !!("" ( !!("" .//!("" (( !).  (($!(  \'(/,!(  $   !(  $   !////////#$9!6="42#<<';
            var level_3 = '////////(   ( !!(   ( !!(   ( !!(-( (\'#!((( (\'#-(   ,/ %(   (\' %((( (\'"%(-( (\'"%(   (\'"!(  $(\'.!(  $($"!(  \'.$ !(!/,"\'//(!"$  !!(     !!(!"$  !!//.$" !!(! \'.//)(! $(  !)/#,(  !(   ( \'/(!#,( &!(!" ( &!/!" ( &!(!.\'/ \')(! $!  !(! $!  !(! $!+,!(! $ #,!////////"0-"0*"0\'"-:!33!=5##=#-7#,/#8<#<)"6\'#=%#=/#0(';
            var mapLevels = [
                level_1,
                level_2,
                level_3
            ];
            //for map canvas
            var mouseInput = {
                x:0,
                y:0,
                click:false,
                altClick:false,
                middleClick:false
            }
            //for game canvas
            var mouseInput_game = {
                x:0,
                y:0,
                click:false,
                altClick:false,
                middleClick:false
            }

            class ImageLoader{
                promiseList = [];
                imageList = {};
                constructor(){

                }

                load(url, name){
                    let imageLoader = this;
                    this.promiseList.push(new Promise(function(resolve,reject){
                        imageLoader.imageList[name] = new Image();
                        imageLoader.imageList[name].onload = function(){return resolve();}
                        imageLoader.imageList[name].onerror = function(){return reject();}
                        imageLoader.imageList[name].src = url;
                    }));
                }

                onload(callback){
                    Promise.all(this.promiseList).then(callback);
                }
            }

            class SoundLoader{
                promiseList = [];
                soundList = {};
                constructor(){

                }

                load(url, name){
                    let soundLoader = this;
                    this.promiseList.push(new Promise(function(resolve,reject){
                        soundLoader.soundList[name] = new Audio();
                        soundLoader.soundList[name].oncanplaythrough = function(){return resolve();}
                        soundLoader.soundList[name].onerror = function(){return reject();}
                        soundLoader.soundList[name].src = url;
                    }));
                }

                onload(callback){
                    Promise.all(this.promiseList).then(callback);
                }
            }

            

            var textureLoader = new ImageLoader();
            var soundLoader = new SoundLoader();
            
            //init grid
            var gridSquares = [];
            for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                gridSquares[i] = [];
                for(var ii = 0; ii < ctx.canvas.height/gridSize; ii++){
                    gridSquares[i][ii] = false;
                }
            }


            function generateSeenGrid(){
                for(var i = 0; i < gridSquares.length; i++){
                    dataSquares[i] = [];
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        dataSquares[i][ii] = {
                            seen:false,
                            blocked:false,
                            blockedBy:null
                        };
                    }
                }

            }


            function drawSquares(ctx, gridSize){
                ctx.save();
                ctx.fillStyle = 'blue';
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        if(gridSquares[i][ii] && (dataSquares[i][ii].seen || MAP_EDIT_MODE )){
                            ctx.fillRect(i*gridSize,ii*gridSize,gridSize,gridSize);
                        }
                    }
                }
                ctx.restore();
            }


            

            function generateGrid(gridSize){
                ctx.fillStyle = "black";
                ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
                if(MAP_EDIT_MODE){
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 1;
                    for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                        let lineY = i*gridSize
                        ctx.beginPath();
                        ctx.moveTo(0,lineY);
                        ctx.lineTo(ctx.canvas.width,lineY);
                        ctx.stroke();
                    }
                    for(var i = 0; i < ctx.canvas.height/gridSize; i++){
                        let lineX = i*gridSize
                        ctx.beginPath();
                        ctx.moveTo(lineX,0)
                        ctx.lineTo(lineX, ctx.canvas.height);
                        ctx.stroke();
                    }
                }
            }


            //player first person
            class Hoof{
                isWalking = false;
                isAnimating = false;
                /** @type {CanvasRenderingContext2D} */
                ctx;
                screenX = 150;
                screenY = 160;
                initialY;
                animateSpeed = 0.15;
                topLimit = 20;
                bottomLimit = -20;
                animateMode = 1;
                width = 69;
                height = 240;
                lastStep = 0;
                lastStepType = 1;

                constructor(ctx){
                    this.ctx = ctx;
                    this.screenY = ctx.canvas.height - this.screenY;
                    this.initialY = this.screenY;
                    this.screenX = ctx.canvas.height - this.screenX;
                    this.topLimit += this.screenY;
                    this.bottomLimit += this.screenY;

                }

                playWalkSound(){
                    let now = performance.now();
                    if(now - this.lastStep > 400){
                        if(this.lastStepType == 1){
                            this.lastStepType = 0;
                            soundLoader.soundList['step1'].play();
                        }else{
                            this.lastStepType = 1;
                            soundLoader.soundList['step2'].play();
                        }
                        this.lastStep = now;
                    }
                }
                animate(deltaT){
                    if(keyInputs.s || keyInputs.w){
                        this.isWalking = true;
                        this.isAnimating = true;
                        if(this.lastStep == 0)soundLoader.soundList['ambiance'].play();
                    }else{
                        this.isWalking = false;
                    }

                    if(this.isAnimating){
                        if(this.animateMode == 1){
                            this.screenY += (this.animateSpeed*deltaT)
                        }else{
                            this.screenY -= (this.animateSpeed*deltaT)
                        }
                        
                        
                        if(this.screenY <= this.bottomLimit){
                            this.animateMode = 1;
                            this.screenY = this.bottomLimit;
                        }else if(this.screenY >= this.topLimit){
                            this.animateMode = 0;
                            this.screenY = this.topLimit;
                        }

                        if((this.screenY <= this.bottomLimit || this.screenY >= this.topLimit || Math.abs(this.screenY - this.initialY) <= 2) && !this.isWalking){
                            this.isAnimating = false;
                        }

                    }

                    if(this.isWalking){
                        this.playWalkSound();
                    }
                    
                }

                draw(){
                    this.ctx.drawImage(textureLoader.imageList['hoof'], Math.round(this.screenX), Math.round(this.screenY), this.width, this.height);
                }

            }

            

            class Sprite{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                xPos;
                yPos;
                zPos;
                directionX;
                directionY;
                image;
                width;
                distance;
                active = true;
                seen = false;
                delete = false;

                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    this.ctx = ctx;

                    this.image = image;
                    this.xPos = xPos;
                    this.yPos = yPos;
                    this.zPos = zPos;
                    this.width = width/gridSize;
                    this.height = height;
                }
                deleteSprite(){
                    this.delete = true;
                }
                draw(player){
                    if(!this.active) return true;
                }

                isVisible(player, rayIntersections){
                    if(!this.active) return true;
                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;


                    let gridAngle = Math.atan2(yRelative, xRelative);

                    let playerAngle = Math.atan2(player.directionY, player.directionX);

                    
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    let edgeDistance = Math.sqrt(Math.pow(playerDistance,2) + Math.pow(this.width/2,2));
                    
                    let edgeAngle = Math.atan2(playerDistance, this.width/2);


                    let lineAngle = (gridAngle - Math.PI/2);
                    let linedx = Math.cos(lineAngle);
                    let linedy = Math.sin(lineAngle);
                    
                    let edge1x = this.xPos/gridSize + (linedx*this.width/2);
                    let edge1y = this.yPos/gridSize + (linedy*this.width/2);

                    let edge2x = this.xPos/gridSize - (linedx*this.width/2);
                    let edge2y = this.yPos/gridSize - (linedy*this.width/2);

                    let yRelative2 = (player.yPos/gridSize) - edge1y;
                    let xRelative2 = (player.xPos/gridSize) - edge1x;
                    let edgeAngle1 = Math.atan2(yRelative2, xRelative2);

                    let yRelative3 = (player.yPos/gridSize) - edge2y;
                    let xRelative3 = (player.xPos/gridSize) - edge2x;
                    let edgeAngle2 = Math.atan2(yRelative3, xRelative3);
                    
                    
                    
                    edgeAngle1 = (edgeAngle1 - Math.PI);
                    edgeAngle2 = (edgeAngle2 - Math.PI);

                    
                    let ay = Math.sin(edgeAngle1);
                    let ax = Math.cos(edgeAngle1);

                    let cy = Math.sin(edgeAngle2);
                    let cx = Math.cos(edgeAngle2);
                    let AxC = ay*cx - ax*cy;
                    let CxA = cy*ax - cx*ay;

                    



                    //these have bad names
                    let a1y = Math.sin(edgeAngle1);
                    let a1x = Math.cos(edgeAngle1);

                    let c1y = Math.sin(edgeAngle2);
                    let c1x = Math.cos(edgeAngle2);
                    let AxC1 = a1y*cx - a1x*c1y;
                    let CxA1 = c1y*ax - c1x*a1y;
                    
                    
                    let b1y = ay;
                    let b1x = ax;
                    let AxB1 = a1y*b1x - a1x*b1y;
                    let CxB1 = c1y*b1x - c1x*b1y;

                    let b2y = cy;
                    let b2x = cx;
                    let AxB2 = a1y*b2x - a1x*b2y;
                    let CxB2 = c1y*b2x - c1x*b2y;
                    

                    //test if the edges of the sprite are within the view cone for performance
                    if(!((AxB1 * AxC1 >= 0 && CxB1 * CxA1 >= 0) || AxB2 * AxC1 >= 0 && CxB2 * CxA1 >= 0)){
                        return false;
                    }
                    
                    for(const pixel in rayIntersections){
                        
                        if(rayIntersections[pixel].distance <= playerDistance){
                            continue;
                        }else{
                            //ray touches sprite

                            let by = Math.sin(rayIntersections[pixel].angle);
                            let bx = Math.cos(rayIntersections[pixel].angle);

                            let AxB = ay*bx - ax*by;
                            let CxB = cy*bx - cx*by;
                            
                            //vector b lies within a and c
                            if(AxB * AxC >= 0 && CxB * CxA >= 0){
                                let coord = edgeAngle1 - edgeAngle2;
                                let angle = edgeAngle1 - rayIntersections[pixel].angle;
                                let percent = angle/coord;

                                let diffAngle = rayIntersections[pixel].angle - gridAngle
                                
                                let segment = Math.tan(diffAngle)*playerDistance;

                                let linesegment = (segment + this.width/2)/this.width
                                this.seen = true;

                                if(this.direction){ //for wall like sprites
                                    let intersect = 0;
                                    let testPos;
                                    if(this.direction == 'x'){
                                        let dx = Math.cos(rayIntersections[pixel].angle);
                                        let dy = Math.sin(rayIntersections[pixel].angle);
                                        intersect = dy*(xRelative/dx);
                                        testPos = yRelative;
                                        playerDistance = Math.sqrt(Math.pow(intersect, 2) + Math.pow(xRelative, 2));
                                    }else{
                                        let dx = Math.cos(rayIntersections[pixel].angle);
                                        let dy = Math.sin(rayIntersections[pixel].angle);
                                        intersect = dx*(yRelative/dy);
                                        testPos = xRelative;
                                        playerDistance = Math.sqrt(Math.pow(intersect, 2) + Math.pow(yRelative, 2));
                                    }
                                    if(Math.abs(intersect - testPos) <= 1){
                                        spriteRenders.push(
                                            {
                                                pixel:pixel,
                                                distance: playerDistance,
                                                texture: this.image,
                                                textureCoordinate : Math.abs(Math.floor(this.image.width * Math.abs(linesegment))),
                                            }
                                        );
                                    }

                                }else{ //for always facing player sprites
                                    spriteRenders.push(
                                        {
                                            pixel:pixel,
                                            distance: playerDistance,
                                            texture: this.image,
                                            textureCoordinate : Math.abs(Math.floor(this.image.width * linesegment)),
                                        }
                                    );
                                }

                                
                            }
                        }
                    }

                }
            }
            
            class Grass extends Sprite{
                lastSound = 0;
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                }

                isVisible(player, rayIntersections){
                    
                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    if(playerDistance < 0.3){
                        if(performance.now() - this.lastSound > 1000 && (keyInputs.w || keyInputs.a || keyInputs.s || keyInputs.d)){
                            soundLoader.soundList['bush'].play();
                            this.lastSound = performance.now();
                        }
                        
                    }
                    super.isVisible(player, rayIntersections);
                }
            }

            

            class Teleporter extends Sprite{
                lastSound = 0;
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                }

                draw(player){
                    if(!this.active) return true;
                    this.ctx.save();
                    this.ctx.fillStyle = "yellow";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 6, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.restore();
                }

                isVisible(player, rayIntersections){
                    if(this.active){
                        let yRelative = ( this.yPos - player.yPos)/gridSize;
                        let xRelative = ( this.xPos - player.xPos)/gridSize;
                        let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                        if(playerDistance < 0.2){
                            if(performance.now() - this.lastSound > 1000 && (keyInputs.w || keyInputs.a || keyInputs.s || keyInputs.d)){
                                soundLoader.soundList['bush'].play();
                                this.lastSound = performance.now();
                                userInterface.startSceneChange();
                            }
                            
                        }
                    }
                    super.isVisible(player, rayIntersections);
                }
            }

            class Splash{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                borderWidth = 4;
                insetWidth = 2;
                isOpen;
                splashImg;
                lastFlash = 0;

                constructor(ctx, splashImg){
                    this.ctx = ctx;
                    this.splashImg = splashImg;
                    this.isOpen = true;
                }
                close(){
                    this.ctx.canvas.style.cursor = "auto";
                    this.isOpen = false;
                }
                open(){
                    this.isOpen = true;
                }

                draw(deltaT){

                    if((mouseInput_game.y > this.ctx.canvas.height - 100 && mouseInput_game.click)|| keyInputs[" "]){
                        canvas.style.visibility = "visible";
                        this.close();
                        return true;
                    }else{
                        canvas.style.visibility = "hidden";
                    }
                    
                    this.ctx.drawImage(this.splashImg, 0,0,this.ctx.canvas.width, this.ctx.canvas.height);
                    this._drawInsetBox(0,0,this.ctx.canvas.width,100);
                    this.ctx.save();
                    this.ctx.fillStyle = "white";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "28px sans-serif";
                    this.ctx.fillText("START", this.ctx.canvas.width/2, this.ctx.canvas.height - 40);
                    if(performance.now() -  this.lastFlash >= 500){
                        if(performance.now() -  this.lastFlash >= 1000){
                        this.lastFlash = performance.now();
                        }
                        this.ctx.fillText(">", this.ctx.canvas.width/2 - 60, this.ctx.canvas.height - 40);
                    }

                    if(mouseInput_game.y > this.ctx.canvas.height - 100){
                        this.ctx.strokeStyle = "white";
                        this.ctx.strokeRect(this.ctx.canvas.width/2 - 100, this.ctx.canvas.height - 75, 200,50);
                        this.ctx.canvas.style.cursor = "pointer";
                    }else{
                        this.ctx.canvas.style.cursor = "auto";
                    }
                    
                    this.ctx.restore();
                }

                //x y relative bottom left
                _drawInsetBox(x,y,width, height){
                    this.ctx.fillStyle = "teal";
                    this.ctx.fillRect(x, y+this.ctx.canvas.height - height, width, height);
                    
                    this.ctx.fillStyle = "grey"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);

                    this.ctx.fillStyle = "white"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - this.borderWidth - this.insetWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+width - 2*this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);
                    
                    this.ctx.fillStyle = "darkSlateGrey";
                    this.ctx.fillRect(x+this.borderWidth + this.insetWidth, y+this.ctx.canvas.height - height + this.borderWidth + this.insetWidth, width - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, height - 2*(this.insetWidth + this.borderWidth));
                    
                }

            }

            class UserInterface{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                faceImg;
                imgLayerBlink;
                imgLayerClose;
                imgLayerBlush;

                netxBlink = 0;
                nextClose = 0;
                blinking = false;
                closed = false;
                faceSize = 100;
                borderWidth = 4;
                insetWidth = 2;
                oldScore = 0;
                blush = false;
                blushStart = 0;
                effectStart = 0;
                effectActive = false;

                constructor(ctx, faceImg, blink, closed, blush){
                    this.ctx = ctx;
                    this.faceImg = faceImg;
                    this.imgLayerBlink = blink;
                    this.imgLayerClose = closed;
                    this.imgLayerBlush = blush;
                }

                update(){
                    let now = performance.now();
                    if(now > this.netxBlink){
                        if(this.netxBlink != 0){
                             this.blinking = true;
                        }
                        if(now - this.netxBlink > 500){
                            this.blinking = false;
                            this.netxBlink = now + ((Math.random() * 5000) + 2500);
                            
                        }
                    }

                    if(now > this.nextClose){
                        this.closed = true;
                        if(now - this.nextClose > 4000){
                            if(this.nextClose != 0) this.closed = false;
                            this.nextClose = now + ((Math.random() * 10000) + 5000);
                        }
                    }

                    if(this.blush && now - this.blushStart > 1000 && this.blushStart != 0){
                        this.blush = false;
                        this.blinking = false;
                        this.nextClose = now + ((Math.random() * 5000) + 5000);
                        this.netxBlink = now + ((Math.random() * 5000) + 2500);
                    }else if(now - this.blushStart <= 1000 && this.blushStart != 0){
                        this.blinking = true;
                        this.closed = false;
                    }

                    if(this.oldScore < strawbCount){
                        this.oldScore = strawbCount;
                        this.setBlush();
                        soundLoader.soundList['bleat'].play();
                        if(sceneScore == sceneGoal){
                            teleporter.active = true;
                        }
                    }
                }

                setBlinking(){
                    this.blinking = true;
                    this.netxtBlink = performance.now();
                }

                setClosed(){
                    this.closed = true;
                    this.nextClose = performance.now();
                }

                setOpen(){
                    this.closed = false;
                    this.nextClose = performance.now() + ((Math.random() * 10000) + 5000);
                }

                setBlush(){
                    this.blush = true;
                    this.blinking = true;
                    this.blushStart = performance.now();
                }
                startSceneChange(){
                    this.effectActive = true;
                    this.effectStart = performance.now();
                }
                sceneChange(deltaT, player){
                    let changeDuration = 1000;
                    let now = performance.now();
                    let alpha = (now - this.effectStart)/changeDuration;
                    if(alpha > 1){
                        alpha = 1;
                        if(now - this.effectStart > 2000){
                            levelCounter++;
                            if(levelCounter >= mapLevels.length) levelCounter = 0;
                            mapFromCode(mapLevels[levelCounter]);
                            generateWorld();
                            player.xPos = 256;
                            player.yPos = 256;
                            this.effectStart = 0;
                            this.effectActive = 0;
                        }
                    }
                    this.ctx.save();
                    this.ctx.fillStyle = "rgba(0,0,0,"+alpha.toFixed(2)+")";
                    this.ctx.fillRect(0,0,this.ctx.canvas.width, this.ctx.canvas.height);
                    this.ctx.fillStyle = "rgba(255,255,255,"+alpha.toFixed(2)+")";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "bold 32px sans-serif"
                    this.ctx.fillText("Zzzz...",255,255);
                    this.ctx.restore();

                }

                _drawReadyNest(){
                    this.ctx.save();
                    this._drawInsetBox(this.ctx.canvas.width/2 - 100,50-this.ctx.canvas.height,200, 50);
                    this.ctx.fillStyle = "white";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "bold 20px sans-serif"
                    this.ctx.fillText("Ready to nest",255,32);
                    this.ctx.restore();
                }

                _drawRemaining(){
                    this.ctx.save();
                    this._drawInsetBox(0,0-this.faceSize, this.faceSize, 25);
                    this.ctx.fillStyle = "grey";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "12px sans-serif"
                    this.ctx.fillText((sceneGoal - sceneScore)+" to go",this.faceSize/2,this.ctx.canvas.height - this.faceSize - 8);
                    this.ctx.restore();
                }

                _drawFaceFrame(){
                    //face frame
                    this.ctx.save();
                    this._drawInsetBox(0,0,this.faceSize, this.faceSize)
                    this.ctx.drawImage(this.faceImg, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))

                    if(this.blinking){
                        this.ctx.drawImage(this.imgLayerBlink, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }
                    if(this.closed){
                        this.ctx.drawImage(this.imgLayerClose, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }

                    if(this.blush){
                        this.ctx.drawImage(this.imgLayerBlush, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }


                    this.ctx.restore();
                }

                //x y relative bottom left
                _drawInsetBox(x,y,width, height){
                    this.ctx.fillStyle = "teal";
                    this.ctx.fillRect(x, y+this.ctx.canvas.height - height, width, height);
                    
                    this.ctx.fillStyle = "grey"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);

                    this.ctx.fillStyle = "white"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - this.borderWidth - this.insetWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+width - 2*this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);
                    
                    this.ctx.fillStyle = "darkSlateGrey";
                    this.ctx.fillRect(x+this.borderWidth + this.insetWidth, y+this.ctx.canvas.height - height + this.borderWidth + this.insetWidth, width - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, height - 2*(this.insetWidth + this.borderWidth));
                    
                }

                _drawScore(){
                    let scoreBox = 50;
                    this.ctx.save();
                    this._drawInsetBox(this.faceSize, 0, scoreBox, scoreBox)
                    this.ctx.font = "bold 28px sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillStyle = "white";
                    this.ctx.fillText(strawbCount, this.faceSize + this.borderWidth + this.insetWidth + (scoreBox - 2*(this.borderWidth + this.insetWidth))/2, this.ctx.canvas.height - (2*this.borderWidth + this.insetWidth) - 4);
                    this.ctx.restore();
                }

                _nearestArrow(player){
                    let closestIndex = 0;
                    let closestDistance = Infinity;
                    for(var i = 0; i < spriteList.length; i++){
                        if(spriteList[i] instanceof StrawberrySprite && spriteList[i].active){
                            let thisDistance = Math.abs(spriteList[i].xPos - player.xPos) + Math.abs(spriteList[i].yPos - player.yPos);
                            if(closestDistance > thisDistance){
                                closestDistance = thisDistance;
                                closestIndex = i;
                            }
                        }
                    }
                    let dx = spriteList[closestIndex].xPos - player.xPos
                    let dy = spriteList[closestIndex].yPos - player.yPos
                    let hp = Math.sqrt(Math.pow(dy,2) + Math.pow(dx, 2));

                    dx = dx/hp;
                    dy = dy/hp;

                    let dot = dy * player.directionY + dx * player.directionX;
                    let cross = dx * player.directionY - dy * player.directionX;
                     
                    let nearestAngle = -1*(Math.PI/2 * cross) - Math.PI/2
                    if(dot < 0) nearestAngle = (nearestAngle) *-1;
                    let scoreBox = 50;
                    this.ctx.save();
                    this._drawInsetBox(this.faceSize, 0-scoreBox, scoreBox, scoreBox)
                    this.ctx.beginPath();
                    this.ctx.fillStyle = "grey";
                    let arcX = this.faceSize + this.borderWidth + this.insetWidth + (scoreBox - 2*(this.borderWidth + this.insetWidth))/2 -1;
                    let arcY = this.ctx.canvas.height - (scoreBox/2) - scoreBox;
                    this.ctx.arc(arcX, arcY, 16, 0, 2*Math.PI);
                    this.ctx.fill();
                    if(sceneScore == sceneGoal){
                        this.ctx.fillStyle = "yellow";
                    }else{
                        this.ctx.fillStyle = "red";
                    }
                    this.ctx.beginPath();
                    this.ctx.moveTo(arcX,arcY);
                    this.ctx.lineTo(arcX + Math.cos(nearestAngle - (Math.PI/8)) * 16, arcY+ Math.sin(nearestAngle - (Math.PI/8)) * 16);
                    this.ctx.arc(arcX, arcY, 16, nearestAngle - (Math.PI/8), nearestAngle + (Math.PI/8));
                    this.ctx.lineTo(arcX,arcY);
                    this.ctx.fill();
                    this.ctx.restore();
                }

                _drawKeys(){
                    let typeCount = 0;
                    for(const type in keyCount){
                        switch(type){
                            case '1':
                                var keyImg = "key";
                            break;
                            case '2':
                                var keyImg = "key_silver";
                            break;
                            case '3':
                                var keyImg = "key_bronze";
                            break;
                        }
                        for(var i = 0; i < keyCount[type]; i++){
                            this.ctx.drawImage(textureLoader.imageList[keyImg], this.faceSize - 40 + (i*4), this.ctx.canvas.height - 60 + (i*4) + (typeCount*8), 40,40);
                        }
                        typeCount++;
                    }
                }

                draw(deltaT, player){
                    this._drawFaceFrame();
                    this._drawScore();
                    this._drawRemaining()
                    this._nearestArrow(player);
                    if(sceneScore == sceneGoal){
                        this._drawReadyNest();
                    }
                    
                    this._drawKeys();
                    
                    if(this.effectActive){
                        this.sceneChange(deltaT, player);
                    }
                }
            }

            class StrawberrySprite extends Sprite{
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                    if(this.active){
                        let yRelative = ( this.yPos - player.yPos)/gridSize;
                        let xRelative = ( this.xPos - player.xPos)/gridSize;
                        let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                        if(playerDistance < 0.3){
                            strawbCount += 1;
                            sceneScore += 1;
                            this.active = false;
                        }
                    }
                }

                draw(player){
                    if(!this.active) return true;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        this.ctx.fillStyle = "red";
                        this.ctx.beginPath();
                        this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
            }

            class KeySprite extends Sprite{
                type;
                constructor(ctx, image, xPos, yPos, zPos, width, height, type){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                    this.type = type;
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                    if(this.active){
                        let yRelative = ( this.yPos - player.yPos)/gridSize;
                        let xRelative = ( this.xPos - player.xPos)/gridSize;
                        let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                        if(playerDistance < 0.3){
                            if(!keyCount[this.type]) keyCount[this.type] = 0;
                            keyCount[this.type] += 1;
                            this.active = false;
                            soundLoader.soundList['key'].play();
                        }
                    }
                }

                draw(player){
                    if(!this.active) return true;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        switch(this.type){
                            case 1:
                                this.ctx.fillStyle = "gold";
                            break;
                            case 2:
                                this.ctx.fillStyle = "silver";
                            break;
                            case 3:
                                this.ctx.fillStyle = "#CD7F32";
                            break;
                        }
                        
                        this.ctx.beginPath();
                        this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
            }

            class DoorSprite extends Sprite{
                direction;
                open = false;
                openImg;
                closedImg;
                type;
                constructor(ctx, openImg, closedImg, xPos, yPos, width, height, direction, type){
                    super(ctx, closedImg, xPos, yPos, 0, width, height);
                    this.direction = direction;
                    this.openImg = openImg;
                    this.closedImg = closedImg;
                    this.type = type;
                    //block own square
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked = true;
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blockedBy = this;
                }

                deleteSprite(){
                    let gridX = Math.floor(this.xPos/gridSize);
                    let gridY = Math.floor(this.yPos/gridSize);
                    this.active = false;
                    dataSquares[gridX][gridY].blocked = false;
                    dataSquares[gridX][gridY].blockedBy = null;
                    super.deleteSprite()
                }
                setOpen(){
                    this.open = true;
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked = false;
                    this.image = this.openImg;
                }

                setClosed(){
                    this.open = false;
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked = true;
                    this.image = this.closedImg;
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    if(playerDistance < 0.6 && keyCount[this.type] > 0 && !this.open){
                        keyCount[this.type] -= 1;
                        this.setOpen();
                        soundLoader.soundList['unlock'].play();
                        soundLoader.soundList['bleat'].play();
                    }
                }

                

                draw(player){
                    if(!this.active) return false;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        switch(this.type){
                            case 1:
                                this.ctx.strokeStyle = "gold";
                            break;
                            case 2:
                                this.ctx.strokeStyle = "silver";
                            break;
                            case 3:
                                this.ctx.strokeStyle = "#CD7F32";
                            break;
                        }
                        this.ctx.lineWidth = 4;
                        this.ctx.beginPath();
                        if(this.direction == 'x'){ //blocking the x direction
                            
                            this.ctx.moveTo(this.xPos, this.yPos - gridSize/2);
                            this.ctx.lineTo(this.xPos, this.yPos + gridSize/2);
                        }else{
                            
                            this.ctx.moveTo(this.xPos - gridSize/2, this.yPos);
                            this.ctx.lineTo(this.xPos + gridSize/2, this.yPos);
                        }
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
            }

            class Player{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                xPos;
                yPos;
                speed = 80;
                rSpeed = 200;
                directionX = 0;
                directionY = 0;

                constructor(ctx, xPos, yPos){
                    this.ctx = ctx;
                    this.xPos = xPos;
                    this.yPos = yPos;
                }
                draw(){
                    this.ctx.save()
                    this.ctx.fillStyle = "green";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "yellow";
                    this.ctx.lineWidth = 4;
                    this.ctx.moveTo(this.xPos, this.yPos);
                    this.ctx.lineTo(this.xPos + this.directionX*10, this.yPos + this.directionY*10);
                    this.ctx.stroke();
                    this.ctx.restore();
                }
                animate(deltaT){

                    let dy = 0;
                    let dx = 0;
                    if(keyInputs.w){
                        dy -= this.speed * deltaT/1000;
                    }
                    if(keyInputs.s){
                        dy += this.speed * deltaT/1000;
                    }

                    
                    if(keyInputs.a){
                        dx -= this.rSpeed * deltaT/1000;
                    }
                    if(keyInputs.d){
                        dx += this.rSpeed * deltaT/1000;
                    }

                    if(dx != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        let newAngle = viewAngle + ( dx * 0.0174533);
                        this.directionY = Math.sin(newAngle);
                        this.directionX = Math.cos(newAngle);
                    }

                    if(dy != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        let nextY = this.yPos - Math.sin(viewAngle)*dy;
                        let nextX = this.xPos - Math.cos(viewAngle)*dy;

                        let nextGridY = Math.floor(nextY/gridSize);
                        let nextGridX = Math.floor(nextX/gridSize);

                        if(gridSquares[nextGridX] && !gridSquares[nextGridX][nextGridY] && !dataSquares[nextGridX][nextGridY].blocked){
                            this.yPos = nextY;
                            this.xPos = nextX;
                        }

                        this.yPos = Math.max(this.yPos, 0);
                        this.yPos = Math.min(this.yPos, ctx.canvas.height);

                        this.xPos = Math.max(this.xPos, 0);
                        this.xPos = Math.min(this.xPos, ctx.canvas.width);
                    }
                }
            }

            hoof = new Hoof(ctxCamera);

            player = new Player(ctx, 256, 256);
            rayIntersections = {};


            function drawMouse(ctx){
                if(MAP_EDIT_MODE){
                    ctx.save()
                    ctx.fillStyle = "teal";
                    ctx.beginPath();
                    ctx.arc(Math.round(mouseInput.x), Math.round(mouseInput.y), 4, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            function paintSquares(mouseInput, gridSize){
                if((mouseInput.click || mouseInput.altClick || mouseInput.middleClick) && MAP_EDIT_MODE){
                    let gridX = Math.floor(mouseInput.x/gridSize);
                    let gridY = Math.floor(mouseInput.y/gridSize);

                    let button = 0;
                    if(mouseInput.click){
                        button = 0;
                    }else if(mouseInput.altClick){
                        button = 2;
                    }else if(mouseInput.middleClick && keyInputs.Shift){
                        button = 3;
                    }else if(mouseInput.middleClick){
                        button = 1;
                    }

                    if(gridX < gridSquares.length){
                        if(gridY < gridSquares[gridX].length){
                            

                            //only do each action once per square unless user mouse ups
                            if(lastMouseAction.gridX != gridX || lastMouseAction.gridY != gridY || lastMouseAction.button != button){

                                //grid wall operations remove sprites
                                if(mouseInput.click || mouseInput.altClick){
                                    for(var i = 0 ; i < spriteList.length; i++){
                                        if(spriteList[i]){
                                            if(Math.floor(spriteList[i].xPos/gridSize) == gridX && Math.floor(spriteList[i].yPos/gridSize) == gridY){
                                                spriteList[i].deleteSprite();
                                            }
                                        }
                                    }
                                }

                                if(mouseInput.click){
                                    gridSquares[gridX][gridY] = true;
                                }else if(mouseInput.altClick){
                                    gridSquares[gridX][gridY] = false;
                                }else if(mouseInput.middleClick && keyInputs.Shift){
                                    let keyFound = false;
                                    for(var i = 0 ; i < spriteList.length; i++){
                                        if(spriteList[i]){
                                            if(Math.floor(spriteList[i].xPos/gridSize) == gridX && Math.floor(spriteList[i].yPos/gridSize) == gridY){
                                                if(spriteList[i] instanceof KeySprite){
                                                    switch(spriteList[i].type){
                                                        case 1:
                                                            spriteList[i].type = 2;
                                                            spriteList[i].image = textureLoader.imageList['key_silver'];
                                                        break;
                                                        case 2:
                                                            spriteList[i].type = 3;
                                                            spriteList[i].image = textureLoader.imageList['key_bronze'];
                                                        break;
                                                        case 3:
                                                            spriteList[i].type = 1;
                                                            spriteList[i].image = textureLoader.imageList['key'];
                                                        break;
                                                    }
                                                    keyFound = true;
                                                }
                                            }
                                        }
                                    }
                                    if(!keyFound){
                                        spriteList.push(new KeySprite(ctx, textureLoader.imageList['key'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, 1));
                                    }
                                }else if(mouseInput.middleClick){
                                    //swap direction on repeats
                                    if(dataSquares[gridX][gridY].blockedBy instanceof DoorSprite){
                                        if(dataSquares[gridX][gridY].blockedBy.direction == 'x'){
                                            dataSquares[gridX][gridY].blockedBy.direction = 'y';
                                        }else{
                                            dataSquares[gridX][gridY].blockedBy.direction = 'x';
                                            if(dataSquares[gridX][gridY].blockedBy.type < 3){
                                                dataSquares[gridX][gridY].blockedBy.type += 1;
                                            }else{
                                                dataSquares[gridX][gridY].blockedBy.type = 1;
                                            }
                                            
                                        }
                                    }else{
                                        spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', 1));
                                    }
                                    
                                }
                                lastMouseAction.gridX = gridX;
                                lastMouseAction.gridY = gridY;
                                lastMouseAction.button = button;
                            }
                        }
                    }
                    generateMapCode();
                }
            }

            function compareDistance(a,b){
                if ( a.distance > b.distance ){
                    return -1;
                }
                if ( a.distance < b.distance ){
                    return 1;
                }
                return 0;
            }

            function drawCamera(ctxCamera, rayIntersections){
                ctxCamera.save();
                let skygrad = ctxCamera.createLinearGradient(0, ctxCamera.canvas.height/4, 0, ctxCamera.canvas.height/2);
                skygrad.addColorStop(0, "skyblue");
                skygrad.addColorStop(1, "white");

                ctxCamera.fillStyle = "skyblue";
                ctxCamera.fillRect(0,0,ctxCamera.canvas.width,ctxCamera.canvas.height/2);

                ctxCamera.fillStyle = skygrad;
                ctxCamera.fillRect(0,ctxCamera.canvas.height/4,ctxCamera.canvas.width,ctxCamera.canvas.height/4);

                let groundGrad = ctxCamera.createLinearGradient(0, ctxCamera.canvas.height/2, 0, ctxCamera.canvas.height*0.75);
                groundGrad.addColorStop(0, "#628251");
                groundGrad.addColorStop(1, "#7ca666");

                ctxCamera.fillStyle = "#7ca666";
                ctxCamera.fillRect(0,ctxCamera.canvas.height/2,ctxCamera.canvas.width,ctxCamera.canvas.height/2);

                ctxCamera.fillStyle = groundGrad;
                ctxCamera.fillRect(0,ctxCamera.canvas.height/2,ctxCamera.canvas.width,ctxCamera.canvas.height/4);
                //draw walls
                for(var i = 0; i < resolution; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(rayIntersections[i] && rayIntersections[i].intersects){
                        let height =  256 * (1/rayIntersections[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;
                        ctxCamera.drawImage(textureLoader.imageList[rayIntersections[i].texture], rayIntersections[i].textureCoordinate, 0, 1, textureLoader.imageList[rayIntersections[i].texture].height, i*width, yOffset, width, height)
                    }
                }

                spriteRenders.sort(compareDistance);

                for(var i = 0; i < spriteRenders.length; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(spriteRenders[i]){
                        let height =  256 * (1/spriteRenders[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;

                        ctxCamera.drawImage(spriteRenders[i].texture, spriteRenders[i].textureCoordinate, 0, 1, spriteRenders[i].texture.height, spriteRenders[i].pixel*width, yOffset, width, height)
                        
                    }
                }
                

                ctxCamera.restore();
            }

            //main update loop
            function play(deltaT){
                var frameStart = performance.now();
                if(splashScreen.isOpen){
                    splashScreen.draw();
                }else{
                    spriteRenders = [];
                    for(var i = 0; i < spriteList.length; i++){
                        if(spriteList[i] && spriteList[i].delete){
                            spriteList[i] = null;
                        }
                    }
                    generateGrid(gridSize);
                    paintSquares(mouseInput, gridSize);
                    drawSquares(ctx, gridSize);
                    drawMouse(ctx);
                    player.animate(deltaT);
                    player.draw();
                    rayCastView(ctx, player);
                    for(var i = 0; i < spriteList.length; i++){
                        if(spriteList[i]){
                            spriteList[i].draw(player);
                            spriteList[i].isVisible(player, rayIntersections);
                        }
                    }
                    drawCamera(ctxCamera, rayIntersections);
                    hoof.animate(deltaT);
                    hoof.draw();

                    userInterface.update();
                    userInterface.draw(deltaT, player);

                    if(keyInputs.m != true && !MAP_EDIT_MODE){
                        ctx.fillStyle = "#333";
                        ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
                        ctx.fillStyle = "grey";
                        ctx.font = "bold 32px sans-serif";
                        ctx.textAlign = "center";
                        ctx.fillText("Hold m for map..", ctx.canvas.width/2, ctx.canvas.height/2);
                        ctx.font = "bold 16px sans-serif";
                        ctx.fillText("(if you get lost)", ctx.canvas.width/2, ctx.canvas.height/2 + 32);
                    }
                }
                window.requestAnimationFrame(function(){
                    play(performance.now() - frameStart);
                });
            }


            //check for intersections with walls
            //start and end in grid space
            function castRay(viewAngle, startCellX, startCellY){
                let dx = Math.cos(viewAngle);
                let dy = Math.sin(viewAngle);

                let xRay = 0;
                let yRay = 0;

                //scaling factor step size
                let sx =  Math.sqrt(1 + Math.pow(dy/dx,2));
                let sy = Math.sqrt(1 + Math.pow(dx/dy,2));

                let tileCheckX = Math.floor(startCellX);
                let tileCheckY = Math.floor(startCellY);

                //step directions
                let xStep;
                if(dx < 0){
                    xStep = -1;
                    xRay = (startCellX - tileCheckX) * sx;
                }else{
                    xStep = 1;
                    xRay = (tileCheckX + 1 - startCellX) * sx;
                }
                
                let yStep;
                if(dy < 0){
                    yStep = -1;
                    yRay = (startCellY - tileCheckY) * sy;
                }else{
                    yStep = 1;
                    yRay = (tileCheckY + 1 - startCellY) * sy;
                }

                let tileFound = false;
                let rayLength = 0;
                let side;
                while(!tileFound && rayLength < 512){
                    if(xRay < yRay){
                        tileCheckX += xStep;
                        rayLength = xRay;
                        xRay += sx;
                        side = "x";
                    }else{
                        tileCheckY += yStep;
                        rayLength = yRay;
                        yRay += sy;
                        side = "y";
                    }

                    if(tileCheckX >= 0 &&  tileCheckY >= 0 && tileCheckX < gridSquares.length && tileCheckY < gridSquares[tileCheckX].length){
                        if(gridSquares[tileCheckX][tileCheckY]){
                            tileFound = true;
                        }
                    }
                }

                return {
                    tileFound:tileFound,
                    dx:dx,
                    dy:dy,
                    rayLength:rayLength,
                    side:side
                }
            }

            function rayCastView(ctx, player){

                //start and end points in grid space
                let startCellX = player.xPos/gridSize;
                let startCellY = player.yPos/gridSize;

                //unit vector
                let dx = player.directionX;
                let dy = player.directionY;
                let viewAngle = Math.atan2(dy, dx);
                
                for(var i = -1*halfRes; i <= halfRes; i++){
                    let offset = (Math.PI/2)/resolution;
                    let newAngle = viewAngle + offset*i;
                    let intersect = castRay(newAngle, startCellX, startCellY);

                    if(intersect.tileFound){
                        let intersectionX = startCellX + (intersect.dx * intersect.rayLength);
                        let intersectionY = startCellY + (intersect.dy * intersect.rayLength);
                        ctx.save()
                        ctx.fillStyle = "yellow";
                        ctx.beginPath();
                        ctx.arc(Math.round(intersectionX*gridSize), Math.round(intersectionY*gridSize), 4, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.restore();

                        let textureCoordinate;
                        if(intersect.side == "y"){
                            textureCoordinate = Math.floor(32*(intersectionX - Math.floor(intersectionX)));
                        }else{
                            textureCoordinate = Math.floor(32*(intersectionY - Math.floor(intersectionY)));
                        }

                        
                        let gridX = Math.floor(intersectionX);
                        let gridY = Math.floor(intersectionY);
                        if(intersect.side == "y" &&  intersectionY < startCellY && gridY > 0){
                            gridY -= 1;
                        }
                        if(intersect.side == "x" &&  intersectionX < startCellX && gridX > 0){
                            gridX -= 1;
                        }
                        dataSquares[gridX][gridY].seen = true;
                        
                        rayIntersections[i+halfRes] = {
                            distance:intersect.rayLength,
                            side:intersect.side,
                            angle: newAngle,
                            intersects:true,
                            x:intersectionX,
                            y:intersectionY,
                            textureCoordinate:textureCoordinate,
                            texture:"wall"
                        }
                    }else{
                        rayIntersections[i+halfRes] = {
                            distance:Infinity,
                            side:"",
                            angle:newAngle,
                            intersects:false,
                            x:0,
                            y:0,
                            textureCoordinate:0,
                            texture:""
                        }
                    }
                }
                
            }
            
            function generateMapCode(){
                let binaryString = '';
                let charIndex = 0;
                let thisChar = '';
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        charIndex++;
                        if(gridSquares[i][ii]){
                            thisChar += "1";
                        }else{
                            thisChar += "0";
                        }
                        if(charIndex % 4 == 0){
                            charIndex = 0;
                            
                            binaryString += String.fromCharCode(32 + parseInt(thisChar,2));
                            thisChar = "";
                        }
                        
                        
                    }
                }

                for(var i = 0; i < spriteList.length; i++){
                    if(spriteList[i] instanceof DoorSprite || spriteList[i] instanceof KeySprite){
                        let type;
                        if(spriteList[i] instanceof DoorSprite){
                            if(spriteList[i].direction == 'x'){
                                type = 5 + spriteList[i].type;   
                            }else{
                                type = 8 + spriteList[i].type;
                            }
                        }else{
                            type = 2 + spriteList[i].type;
                        }
                        binaryString += String.fromCodePoint(type + 32);
                        binaryString += String.fromCodePoint(Math.floor(spriteList[i].xPos/gridSize) + 32);
                        binaryString += String.fromCodePoint(Math.floor(spriteList[i].yPos/gridSize) + 32);
                    }
                }

                
                let map_code = document.getElementById("map_code");
                map_code.value = binaryString;
            }

            function mapFromCode(code){
                spriteList = [];
                teleporter = new Teleporter(ctx, textureLoader.imageList['bed'], 256, 256, 0, gridSize, resolution);
                teleporter.active = false;
                spriteList.push(teleporter);
                let binaryString = '';
                let gridCode = code.substr(0,256);
                let spriteCode = code.substr(256);
                for(var c = 0; c < gridCode.length; c++){
                    binaryString += (gridCode.codePointAt(c) - 32).toString(2).padStart(4,"0");
                }
                let cellIndex = 0;
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        
                        if(binaryString.substr(cellIndex,1) == "1"){
                            gridSquares[i][ii] = true;
                        }else{
                            gridSquares[i][ii] = false;
                        }
                        cellIndex++;
                    }
                }
                generateSeenGrid();
                
                for(var i = 0; i < spriteCode.length; i += 3){
                    let type = spriteCode.codePointAt(i) - 32;
                    let gridX = spriteCode.codePointAt(i+1) - 32;
                    let gridY = spriteCode.codePointAt(i+2) - 32;
                    switch(type){
                        case 1: //doorx
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', 1));
                        break;
                        case 2: //doory
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'y', 1));
                        break;
                        case 3: //key
                            spriteList.push(new KeySprite(ctx, textureLoader.imageList['key'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, type - 2));
                        break;
                        case 4:
                            spriteList.push(new KeySprite(ctx, textureLoader.imageList['key_silver'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, type - 2));
                        break;
                        case 5:
                            spriteList.push(new KeySprite(ctx, textureLoader.imageList['key_bronze'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, type - 2));
                        break;

                        case 6: //doorx 
                        case 7: //doorx
                        case 8: //doorx
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', type-5));
                        break;
                        case 9: //doory
                        case 10: //doory
                        case 11: //doory
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'y', type-8));
                        break;
                    }
                }
            }

            load_map_btn.addEventListener("click", function(e){
                e.preventDefault();
                mapFromCode(map_code.value);
                return false;
            })
            
            document.addEventListener("keydown",function(e){
                keyInputs[e.key] = true;
            });

            document.addEventListener("keyup",function(e){
                keyInputs[e.key] = false;
            });

            canvas.addEventListener("mousemove",function(e){
                mouseInput.x = e.offsetX;
                mouseInput.y = e.offsetY;
            });

            canvas.addEventListener("touchmove",function(e){
                mouseInput.y = e.changedTouches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput.x = e.changedTouches[0].clientX - canvas.offsetLeft;
            });

            canvas.addEventListener("mousedown", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = true;
                }else if(e.button == 2){
                    mouseInput.altClick = true;
                }else if(e.button = 1){
                    mouseInput.middleClick = true;
                }
                return false;
            });

            canvas.addEventListener("touchstart", function(e){
                e.preventDefault();
                mouseInput.y = e.touches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput.x = e.touches[0].clientX - canvas.offsetLeft;
                mouseInput.click = true;
                return false;
            });

            canvas.addEventListener("touchend", function(e){
                e.preventDefault();
                mouseInput.click = false;
                return false;
            });

            map_edit_btn.addEventListener("click", function(e){
                e.preventDefault();
                map_edit_container.style.display = "block";
                map_edit_btn.style.display = "none";
                canvas.style.transform = "";
                canvas.style.opacity = "1";
                MAP_EDIT_MODE = true;
                return false;
            })

            

            canvas.addEventListener("mouseup", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = false;
                }else if(e.button == 2){
                    mouseInput.altClick = false;
                }else if(e.button == 1){
                    mouseInput.middleClick = false;
                }
                //reset on mouseup
                lastMouseAction = {
                    button:-1,
                    gridX:0,
                    gridY:0
                };
                return false;
            });

            canvasCamera.addEventListener("mousemove",function(e){
                mouseInput_game.x = e.offsetX;
                mouseInput_game.y = e.offsetY;
            });

            canvasCamera.addEventListener("touchmove",function(e){
                mouseInput_game.y = e.changedTouches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput_game.x = e.changedTouches[0].clientX - canvas.offsetLeft;
            });

            canvasCamera.addEventListener("mousedown", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput_game.click = true;
                }else if(e.button == 2){
                    mouseInput_game.altClick = true;
                }else if(e.button = 1){
                    mouseInput_game.middleClick = true;
                }
                return false;
            });

            canvasCamera.addEventListener("touchstart", function(e){
                e.preventDefault();
                mouseInput_game.y = e.touches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput_game.x = e.touches[0].clientX - canvas.offsetLeft;
                mouseInput_game.click = true;
                return false;
            });

            canvasCamera.addEventListener("touchend", function(e){
                e.preventDefault();
                mouseInput_game.click = false;
                return false;
            });

            canvas.addEventListener("contextmenu",function(e){
                e.preventDefault();
                e.stopPropagation();
                return false;
            });

            canvasCamera.addEventListener("contextmenu",function(e){
                e.preventDefault();
                e.stopPropagation();
                return false;
            });

            canvasCamera.addEventListener("mouseup", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput_game.click = false;
                }else if(e.button == 2){
                    mouseInput_game.altClick = false;
                }else if(e.button == 1){
                    mouseInput_game.middleClick = false;
                }
                return false;
            });

            let keys = document.getElementsByClassName('key');
            for(var i = 0; i < keys.length; i++){
                keys[i].addEventListener('touchstart', function(e){
                    let key = this.getAttribute("data-key");
                    keyInputs[key] = true;
                });
                keys[i].addEventListener('touchend', function(e){
                    let key = this.getAttribute("data-key");
                    keyInputs[key] = false;
                });
                keys[i].addEventListener('contextmenu', function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    return false;

                })
            }

            function createStrawb(x,y){
                strawb  = new StrawberrySprite(ctx, textureLoader.imageList['strawb'], x, y, 0, gridSize, resolution);
                return strawb;
            }
            var teleporter;
            function generateWorld(){
                sceneScore = 0;
                keyCount = {};

                let flowerCount = Math.round(Math.random()*20) + 10;
                let strawbSpawnCount = Math.round(Math.random()*15) + 5;
                sceneGoal = strawbSpawnCount;
                for(var i = 0; i < flowerCount; i++){
                    let thisSpriteX = (Math.round(Math.random() * (ctx.canvas.width - 2*gridSize))) + gridSize;
                    let thisSpriteY = (Math.round(Math.random() * (ctx.canvas.height - 2*gridSize))) + gridSize;
                    if(!gridSquares[Math.floor(thisSpriteX/gridSize)][Math.floor(thisSpriteY/gridSize)]){
                        spriteList.push(new Grass(ctx, textureLoader.imageList['flower'], thisSpriteX, thisSpriteY, 0, gridSize, resolution));
                    }else{
                        i--; //try again
                        console.log("try again")
                    }
                }

                for(var i = 0; i < strawbSpawnCount; i++){
                    let thisSpriteX = (Math.round(Math.random() * (ctx.canvas.width - 2*gridSize))) + gridSize;
                    let thisSpriteY = (Math.round(Math.random() * (ctx.canvas.height - 2*gridSize))) + gridSize;
                    if(!gridSquares[Math.floor(thisSpriteX/gridSize)][Math.floor(thisSpriteY/gridSize)]){
                        spriteList.push(createStrawb(thisSpriteX,thisSpriteY));
                    }else{
                        i--; //try again
                        console.log("try again")
                    }
                    
                }

            }

            function isTouchDevice() {
            return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
            }

            if(!isTouchDevice()){
                touch_input_container.style.display = "none";
            }else{
                canvas.style.display = "none";
                map_edit_btn.style.display = "none";
            }

            soundLoader.load("sound/unlock.mp3", "unlock");
            soundLoader.soundList['unlock'].volume = 0.4;
            soundLoader.load("sound/key.mp3", "key");
            soundLoader.soundList['key'].volume = 0.4;
            soundLoader.load("sound/bush.mp3", "bush");
            soundLoader.soundList['bush'].volume = 0.4;
            soundLoader.load("sound/ambiance.mp3", "ambiance");
            soundLoader.soundList['ambiance'].volume = 0.4;
            soundLoader.soundList['ambiance'].loop = true;
            soundLoader.load("sound/bleat.mp3", "bleat");
            soundLoader.load("sound/step1.mp3", "step1");
            soundLoader.soundList['step1'].volume = 0.3;
            soundLoader.load("sound/step2.mp3", "step2");
            soundLoader.soundList['step2'].volume = 0.3;
            soundLoader.onload(function(){
                textureLoader.load("img/key.png", 'key');
                textureLoader.load("img/key_bronze.png", 'key_bronze');
                textureLoader.load("img/key_silver.png", 'key_silver');
                textureLoader.load("img/door.png", 'door');
                textureLoader.load("img/door-open.png", 'door-open');
                textureLoader.load("img/bed.png", 'bed');
                textureLoader.load("img/wall.png", 'wall');
                textureLoader.load("img/hoof.png", 'hoof');
                textureLoader.load("img/strawb.png", 'strawb');
                textureLoader.load("img/deer-face.png", 'face');
                textureLoader.load("img/deer-face-blink.png", 'face-blink');
                textureLoader.load("img/deer-face-closed.png", 'face-close');
                textureLoader.load("img/deer-blush.png", 'face-blush');
                textureLoader.load("img/flower.png", 'flower');
                textureLoader.load("img/splash.png", 'splash');
                textureLoader.onload(function(){
                    console.log("loaded");
                    let faceImg = textureLoader.imageList['face'];
                    let faceBlink = textureLoader.imageList['face-blink'];
                    let faceClose = textureLoader.imageList['face-close'];
                    let faceBlush = textureLoader.imageList['face-blush'];
                    userInterface = new UserInterface(ctxCamera,  faceImg, faceBlink, faceClose, faceBlush);
                    splashScreen = new Splash(ctxCamera, textureLoader.imageList['splash']);
                    mapFromCode(level_1);
                    generateWorld();
                    play(0);
                });
            });

        </script>
    </body>
    <footer>
        
    </footer>
</html>