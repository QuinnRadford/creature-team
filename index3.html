<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=512, user-scalable=0, viewport-fit=contain"/>
    </head>
    <!--!Font Awesome Free v7.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2026 Fonticons, Inc.-->
    <body>
        <style>
            .controls-container{
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                margin:auto;
                max-width: 400px;
                gap:16px;
                margin-top:35px;
            }
            .controls-container>div{
                flex-basis: calc(33.33% - 16px);
                height:100px;
                
                align-content: center;
                text-align: center;
                border-radius: 8px;
                
            }
            .controls-container>.key{
                outline: 2px solid black;
                background: grey;
                user-select: none;
                cursor: pointer;
            }
            body{
                min-width: 512px;
                background:#333;
                margin:0;
            }
            
            .key[data-key='q']{
                background-image: url("data:image/svg+xml;utf8;,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 640'><path d='M160 320C160 408.4 231.6 480 320 480C348.9 480 376 472.3 399.4 458.9L327.4 372.5C316.1 358.9 317.9 338.7 331.5 327.4C345.1 316.1 365.3 317.9 376.6 331.5L447.5 416.6C467.9 389.8 480 356.3 480 320C480 231.6 408.4 160 320 160C231.6 160 160 231.6 160 320zM440.9 508.6C406 531 364.5 544 320 544C196.3 544 96 443.7 96 320C96 196.3 196.3 96 320 96C443.7 96 544 196.3 544 320C544 376.1 523.4 427.4 489.3 466.7L536.6 523.5C547.9 537.1 546.1 557.3 532.5 568.6C518.9 579.9 498.7 578.1 487.4 564.5L440.8 508.6z'/></svg>");
            }
            .key[data-key='w']{
                background-image: url("data:image/svg+xml;utf8;,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 640'><path d='M52.8 98C69.3 91.8 87.8 100.2 94 116.7L204.2 410.7L289.3 119C293.3 105.3 305.8 96 320 96C334.2 96 346.7 105.4 350.7 119L435.8 410.7L546 116.8C552.2 100.3 570.6 91.9 587.2 98.1C603.8 104.3 612.2 122.7 606 139.2L462 523.2C457.2 536.1 444.6 544.5 430.8 543.9C417 543.3 405.1 534.1 401.3 520.9L320 242.3L238.7 521C234.8 534.2 222.9 543.5 209.2 544C195.5 544.5 182.9 536.2 178 523.3L34 139.2C27.8 122.7 36.2 104.2 52.8 98z'/></svg>");
            }
            .key[data-key='e']{
                background-image: url("data:image/svg+xml;utf8;,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 640'><path d='M192 96C174.3 96 160 110.3 160 128L160 512C160 529.7 174.3 544 192 544L448 544C465.7 544 480 529.7 480 512C480 494.3 465.7 480 448 480L224 480L224 352L384 352C401.7 352 416 337.7 416 320C416 302.3 401.7 288 384 288L224 288L224 160L448 160C465.7 160 480 145.7 480 128C480 110.3 465.7 96 448 96L192 96z'/></svg>");
            }
            .key[data-key='a']{
                background-image: url("data:image/svg+xml;utf8;,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 640'><path d='M349.5 115.7C344.6 103.8 332.9 96 320 96C307.1 96 295.4 103.8 290.5 115.7C197.2 339.7 143.8 467.7 130.5 499.7C123.7 516 131.4 534.7 147.7 541.5C164 548.3 182.7 540.6 189.5 524.3L221.3 448L418.6 448L450.4 524.3C457.2 540.6 475.9 548.3 492.2 541.5C508.5 534.7 516.2 516 509.4 499.7C496.1 467.7 442.7 339.7 349.4 115.7zM392 384L248 384L320 211.2L392 384z'/></svg>");
            }
            .key[data-key='s']{
                background-image: url("data:image/svg+xml;utf8;,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 640'><path d='M160 221.5C160 152.2 216.2 96 285.5 96L432 96C449.7 96 464 110.3 464 128C464 145.7 449.7 160 432 160L285.5 160C251.5 160 224 187.5 224 221.5C224 252.5 247.1 278.7 277.9 282.5L370.1 294C432.9 301.9 480 355.2 480 418.5C480 487.8 423.8 544 354.5 544L208 544C190.3 544 176 529.7 176 512C176 494.3 190.3 480 208 480L354.5 480C388.5 480 416 452.5 416 418.5C416 387.5 392.9 361.3 362.1 357.5L269.9 346C207.1 338.1 160 284.8 160 221.5z'/></svg>");
            }
            .key[data-key='d']{
                background-image: url("data:image/svg+xml;utf8;,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 640 640'><path d='M128 128C128 110.3 142.3 96 160 96L288 96C411.7 96 512 196.3 512 320C512 443.7 411.7 544 288 544L160 544C142.3 544 128 529.7 128 512L128 128zM192 160L192 480L288 480C376.4 480 448 408.4 448 320C448 231.6 376.4 160 288 160L192 160z'/></svg>");
            }
            .key{
                background-size: 40%!important;
                background-position: center!important;
                background-repeat: no-repeat!important;
            }
        </style>
        <canvas id="game" width="512" height="512" style="transform:scale(0.5);">

        </canvas>
        <canvas id="camera" width="512" height="512">

        </canvas>
        <div class="controls-container" id="touch_input_container" style="user-select: none;">
            <div class="key" data-key="q"></div><div class="key" data-key="w"></div><div class="key" data-key="e"></div>
            <div class="key" data-key="a"></div>
            <div class="key" data-key="s"></div>
            <div class="key" data-key="d"></div>
            <div class="key" data-key=" " style="flex-basis:calc(100% - 16px);"></div>
        </div>
        <div id="map_edit_container" style="display:none;">
            <label for="map_code">Map layout code <input name="map_code" id="map_code" value=""/></label><button id="load_map_btn">load</button>
            <select id="map_select"></select>
        </div>
        <br><button id="map_edit_btn">map edit mode</button>

        <script>
            const canvasCamera = document.getElementById('camera');
            /** @type {CanvasRenderingContext2D} */
            const ctxCamera = canvasCamera.getContext('2d');

            const canvas = document.getElementById('game');
            /** @type {CanvasRenderingContext2D} */
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "black";
            ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
            var gridSize = 16;
            var resolution = 128;
            var halfRes = 64;
            var keyInputs = {
                w:false,
                s:false,
                a:false,
                d:false,
                m:false,
                t:false,
                b:false,
                Shift:false,
                Space:false
            };
            var strawb;
            var hoof;
            var player;
            var rayIntersections;
            var spriteList = [];
            var spriteRenders = [];
            var menuOpen = true;

            var MAP_EDIT_MODE = false;

            var strawbCount = 0;
            var sceneGoal = 0;
            var sceneScore = 0;
            var userInterface;
            var splashScreen;
            var keyCount = {};
            var levelCounter = 0;
            var dataSquares = [];
            var startingStrawbs = 0;
            var lastMouseAction = {
                button:-1,
                gridX:0,
                gridY:0
            };

            var level_1 = '/////////( (  #//( (  #//( (  #//( (  #//( (  #//(    #//( (  #//( (  #//( (  #//( (  #//( (  #//( (  #////.////. (    /. (    /. (    /. (    /. (    /. (    /. (    /.      /.      /.      /.      /.      /.      /.      /.      /.      /.      /////////&-/$8.*&,#0%,09,4$,0*,:1,&8,"(,**,:9,+.,#2-$7.$\'';
            var level_2 = '////////(  $   !(  $   !(" $\'( !("&$ ( !("&$ ( !(" $$( !(" $$( !). \',( !)"&$$/#/)"&$$  !)" $   !(" $  "!(" $$ "!)"&\'//.!)"&$   !).     !)(  #/.!((&$" "!((&$. "!((    "!((  " "!/.\',//#+("" ( !!("" ( !!("" .//!("" (( !).  (($!(  \'(/,!(  $   !(  $   !////////#$9)42#<<&6=-$9-:<-$$,"=,1%,2%,3%,4%,5%,>.,=.,:%,7%,)$,)%,!!,#!,.>,0>,,>,2>,7+,-.,)0,!.,8:,7:,81,71,23.=!.,!.:>.<<.%=."8.$7.&(.),.+/';
            var level_3 = '////////(   ( !!(   ( !!(   ( !!(-( (\'#!((( (\'#-(   ,/ %(   (\' %((( (\'"%(-( (\'"%(   (\'"!(  $(\'.!(  $($"!(  \'.$ !(!/,"\'//(!"$  !!(     !!(!"$  !!//.$" !!(! \'.//)(! $(  !)/#,(  !(   ( \'/(!#,( &!(!" ( &!/!" ( &!(!.\'/ \')(! $!  !(! $!  !(! $!+,!(! $ #,!////////)0-)0*)0\')-:&33&=5##=#-7#,/#8<#<))6\'#=%#=/#0(-!,-*"-52->$,&%,\'%,\'&,&&,!/,"/,!.,!+,!&,\'!,,,,>>,81,51,68,78,:8,98,!<,*8,*9,,1,!1,4&,3&,:!,3(,9(,9),8),/:,0:,1:,2:,/<,/>,0<,1<,2<.$!."-.,!.<&.=<.74.<5.#2.">.;/.=#.6)';
            var mapLevels = [
                level_1,
                level_2,
                level_3
            ];
            //for map canvas 
            var mouseInput = {
                x:0,
                y:0,
                click:false,
                altClick:false,
                middleClick:false
            }
            //for game canvas
            var mouseInput_game = {
                x:0,
                y:0,
                click:false,
                altClick:false,
                middleClick:false
            }

            var bulletImageRotation;
            var netImageRotation;

            class ImageLoader{
                promiseList = [];
                imageList = {};
                constructor(){

                }

                load(url, name){
                    let imageLoader = this;
                    this.promiseList.push(new Promise(function(resolve,reject){
                        imageLoader.imageList[name] = new Image();
                        imageLoader.imageList[name].onload = function(){return resolve();}
                        imageLoader.imageList[name].onerror = function(){return reject();}
                        imageLoader.imageList[name].src = url;
                    }));
                }

                onload(callback){
                    Promise.all(this.promiseList).then(callback);
                }
            }

            function precalculateImageRotation(image, effects, frames, width, height){
                let outputImg = [];
                let renderCanvas = new OffscreenCanvas(width,height);
                let ctx = renderCanvas.getContext("2d");
                for(var i = 0; i < frames; i++){ 
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx.save();
                    ctx.translate(ctx.canvas.width/2, ctx.canvas.height/2);
                    ctx.rotate((360/frames) * i *  Math.PI/180);
                    ctx.translate(-1* ctx.canvas.width/2, -1* ctx.canvas.height/2);
                    ctx.drawImage(image, 0,0,width,height);
                    ctx.restore();
                    for(var ii = 0; ii < effects.length; ii++){
                        ctx.drawImage(effects[ii], 0,0,width,height);
                    }
                    outputImg.push(renderCanvas.transferToImageBitmap());
                    
                }
                return outputImg;
            }

            class SoundLoader{
                promiseList = [];
                soundList = {};
                constructor(){

                }

                load(url, name){
                    let soundLoader = this;
                    this.promiseList.push(new Promise(function(resolve,reject){
                        soundLoader.soundList[name] = new Audio();
                        soundLoader.soundList[name].oncanplaythrough = function(){return resolve();}
                        soundLoader.soundList[name].onerror = function(){return reject();}
                        soundLoader.soundList[name].src = url;
                    }));
                }

                onload(callback){
                    Promise.all(this.promiseList).then(callback);
                }
            }

            

            var textureLoader = new ImageLoader();
            var soundLoader = new SoundLoader();
            
            //init grid
            var gridSquares = [];
            for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                gridSquares[i] = [];
                for(var ii = 0; ii < ctx.canvas.height/gridSize; ii++){
                    gridSquares[i][ii] = false;
                }
            }


            function generateSeenGrid(){
                for(var i = 0; i < gridSquares.length; i++){
                    dataSquares[i] = [];
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        
                        let textureX = Math.ceil(Math.random()*4);
                        let textureY = Math.ceil(Math.random()*4);


                        dataSquares[i][ii] = {
                            seen:false,
                            blocked:false,
                            blockedBy:null,
                            texture_x:'wall'+textureX,
                            texture_y:'wall'+textureY
                        };
                    }
                }

            }


            function drawSquares(ctx, gridSize){
                ctx.save();
                ctx.fillStyle = 'blue';
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        if(gridSquares[i][ii] && (dataSquares[i][ii].seen || MAP_EDIT_MODE )){
                            ctx.fillRect(i*gridSize,ii*gridSize,gridSize,gridSize);
                        }
                    }
                }
                ctx.restore();
            }


            

            function generateGrid(gridSize){
                ctx.fillStyle = "black";
                ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
                if(MAP_EDIT_MODE){
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 1;
                    for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                        let lineY = i*gridSize
                        ctx.beginPath();
                        ctx.moveTo(0,lineY);
                        ctx.lineTo(ctx.canvas.width,lineY);
                        ctx.stroke();
                    }
                    for(var i = 0; i < ctx.canvas.height/gridSize; i++){
                        let lineX = i*gridSize
                        ctx.beginPath();
                        ctx.moveTo(lineX,0)
                        ctx.lineTo(lineX, ctx.canvas.height);
                        ctx.stroke();
                    }
                }
            }


            //player first person
            class Hoof{
                isWalking = false;
                isAnimating = false;
                /** @type {CanvasRenderingContext2D} */
                ctx;
                screenX = 150;
                screenY = 160;
                initialY;
                animateSpeed = 0.15;
                topLimit = 20;
                bottomLimit = -20;
                animateMode = 1;
                width = 69;
                height = 240;
                lastStep = 0;
                lastStepType = 1;
                shootStart = 0;
                shootLength = 250
                isShooting;
                lastShotImg = 1;

                constructor(ctx){
                    this.ctx = ctx;
                    this.screenY = ctx.canvas.height - this.screenY;
                    this.initialY = this.screenY;
                    this.screenX = ctx.canvas.height - this.screenX;
                    this.topLimit += this.screenY;
                    this.bottomLimit += this.screenY;
                    
                }

                playWalkSound(){
                    let now = performance.now();
                    if(now - this.lastStep > 400){
                        if(this.lastStepType == 1){
                            this.lastStepType = 0;
                            soundLoader.soundList['step1'].play();
                        }else{
                            this.lastStepType = 1;
                            soundLoader.soundList['step2'].play();
                        }
                        this.lastStep = now;
                    }
                }
                animate(deltaT){
                    if(keyInputs.s || keyInputs.w || keyInputs.e || keyInputs.q || keyInputs.q || keyInputs.e){
                        this.isWalking = true;
                        this.isAnimating = true;
                        if(this.lastStep == 0)soundLoader.soundList['ambiance'].play();
                    }else{
                        this.isWalking = false;
                    }

                    if(this.isAnimating){
                        if(this.animateMode == 1){
                            this.screenY += (this.animateSpeed*deltaT)
                        }else{
                            this.screenY -= (this.animateSpeed*deltaT)
                        }
                        
                        
                        if(this.screenY <= this.bottomLimit){
                            this.animateMode = 1;
                            this.screenY = this.bottomLimit;
                        }else if(this.screenY >= this.topLimit){
                            this.animateMode = 0;
                            this.screenY = this.topLimit;
                        }

                        if((this.screenY <= this.bottomLimit || this.screenY >= this.topLimit || Math.abs(this.screenY - this.initialY) <= 2) && !this.isWalking){
                            this.isAnimating = false;
                        }

                    }

                    

                    if(this.isWalking){
                        this.playWalkSound();
                    }
                    
                }
                shoot(){
                    this.shootStart = performance.now();
                    this.isShooting = true;
                    this.lastShotImg +=  Math.ceil(Math.random()*2);
                    soundLoader.soundList['shoot'].currentTime = 0;
                    soundLoader.soundList['shoot'].play();
                    if(this.lastShotImg > 3) this.lastShotImg -= 3;
                }

                draw(){
                    if(this.isShooting){
                        
                        var shootTime = performance.now() -  this.shootStart;

                        if(shootTime > this.shootLength){
                            this.isShooting = false;
                        }else{
                            this.ctx.save();
                            this.ctx.globalAlpha = 1 - (shootTime/this.shootLength);

                            this.ctx.drawImage(textureLoader.imageList['shoot_'+this.lastShotImg], Math.round(this.screenX) - 120, Math.round(this.screenY)-120, 256, 256);
                            this.ctx.drawImage(textureLoader.imageList['hoof_blue'], Math.round(this.screenX-8), Math.round(this.screenY-8), this.width+16, this.height+16);
                            this.ctx.restore();
                            
                        }
                    }
                    this.ctx.drawImage(textureLoader.imageList['hoof'], Math.round(this.screenX), Math.round(this.screenY), this.width, this.height);
                    
                }

            }

            

            class Sprite{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                xPos;
                yPos;
                zPos;
                directionX;
                directionY;
                image;
                width;
                distance;
                active = true;wd
                seen = false;
                delete = false;

                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    this.ctx = ctx;

                    this.image = image;
                    this.xPos = xPos;
                    this.yPos = yPos;
                    this.zPos = zPos;
                    this.width = width/gridSize;
                    this.height = height;
                }
                deleteSprite(){
                    this.delete = true;
                }
                draw(player){
                    if(!this.active) return true;
                }
                update(deltaT){

                }

                isVisible(player, rayIntersections){
                    if(!this.active) return true;
                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;


                    let gridAngle = Math.atan2(yRelative, xRelative);

                    let playerAngle = Math.atan2(player.directionY, player.directionX);

                    
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    let edgeDistance = Math.sqrt(Math.pow(playerDistance,2) + Math.pow(this.width/2,2));
                    
                    let edgeAngle = Math.atan2(playerDistance, this.width/2);


                    let lineAngle = (gridAngle - Math.PI/2);
                    let linedx = Math.cos(lineAngle);
                    let linedy = Math.sin(lineAngle);
                    
                    let edge1x = this.xPos/gridSize + (linedx*this.width/2);
                    let edge1y = this.yPos/gridSize + (linedy*this.width/2);

                    let edge2x = this.xPos/gridSize - (linedx*this.width/2);
                    let edge2y = this.yPos/gridSize - (linedy*this.width/2);

                    let yRelative2 = (player.yPos/gridSize) - edge1y;
                    let xRelative2 = (player.xPos/gridSize) - edge1x;
                    let edgeAngle1 = Math.atan2(yRelative2, xRelative2);

                    let yRelative3 = (player.yPos/gridSize) - edge2y;
                    let xRelative3 = (player.xPos/gridSize) - edge2x;
                    let edgeAngle2 = Math.atan2(yRelative3, xRelative3);
                    
                    
                    
                    edgeAngle1 = (edgeAngle1 - Math.PI);
                    edgeAngle2 = (edgeAngle2 - Math.PI);

                    
                    let ay = Math.sin(edgeAngle1);
                    let ax = Math.cos(edgeAngle1);

                    let cy = Math.sin(edgeAngle2);
                    let cx = Math.cos(edgeAngle2);
                    let AxC = ay*cx - ax*cy;
                    let CxA = cy*ax - cx*ay;

                    



                    //these have bad names
                    let a1y = Math.sin(edgeAngle1);
                    let a1x = Math.cos(edgeAngle1);

                    let c1y = Math.sin(edgeAngle2);
                    let c1x = Math.cos(edgeAngle2);
                    let AxC1 = a1y*cx - a1x*c1y;
                    let CxA1 = c1y*ax - c1x*a1y;
                    
                    
                    let b1y = ay;
                    let b1x = ax;
                    let AxB1 = a1y*b1x - a1x*b1y;
                    let CxB1 = c1y*b1x - c1x*b1y;

                    let b2y = cy;
                    let b2x = cx;
                    let AxB2 = a1y*b2x - a1x*b2y;
                    let CxB2 = c1y*b2x - c1x*b2y;
                    

                    //test if the edges of the sprite are within the view cone for performance
                    if(!((AxB1 * AxC1 >= 0 && CxB1 * CxA1 >= 0) || AxB2 * AxC1 >= 0 && CxB2 * CxA1 >= 0)){
                        return false;
                    }
                    
                    for(const pixel in rayIntersections){
                        
                        if(rayIntersections[pixel].distance <= playerDistance){
                            continue;
                        }else{
                            //ray touches sprite

                            let by = Math.sin(rayIntersections[pixel].angle);
                            let bx = Math.cos(rayIntersections[pixel].angle);

                            let AxB = ay*bx - ax*by;
                            let CxB = cy*bx - cx*by;
                            
                            //vector b lies within a and c
                            if(AxB * AxC >= 0 && CxB * CxA >= 0){
                                let coord = edgeAngle1 - edgeAngle2;
                                let angle = edgeAngle1 - rayIntersections[pixel].angle;
                                let percent = angle/coord;

                                let diffAngle = rayIntersections[pixel].angle - gridAngle
                                
                                let segment = Math.tan(diffAngle)*playerDistance;

                                let linesegment = (segment + this.width/2)/this.width
                                this.seen = true;

                                if(this.direction){ //for wall like sprites
                                    let intersect = 0;
                                    let testPos;
                                    if(this.direction == 'x'){
                                        let dx = Math.cos(rayIntersections[pixel].angle);
                                        let dy = Math.sin(rayIntersections[pixel].angle);
                                        intersect = dy*(xRelative/dx);
                                        testPos = yRelative;
                                        playerDistance = Math.sqrt(Math.pow(intersect, 2) + Math.pow(xRelative, 2));
                                    }else{
                                        let dx = Math.cos(rayIntersections[pixel].angle);
                                        let dy = Math.sin(rayIntersections[pixel].angle);
                                        intersect = dx*(yRelative/dy);
                                        testPos = xRelative;
                                        playerDistance = Math.sqrt(Math.pow(intersect, 2) + Math.pow(yRelative, 2));
                                    }
                                    if(Math.abs(intersect - testPos) <= 1){
                                        spriteRenders.push(
                                            {
                                                pixel:pixel,
                                                distance: playerDistance,
                                                texture: this.image,
                                                textureCoordinate : Math.abs(Math.floor(this.image.width * Math.abs(linesegment))),
                                            }
                                        );
                                    }

                                }else{ //for always facing player sprites
                                    spriteRenders.push(
                                        {
                                            pixel:pixel,
                                            distance: playerDistance,
                                            texture: this.image,
                                            textureCoordinate : Math.abs(Math.floor(this.image.width * linesegment)),
                                        }
                                    );
                                }

                                
                            }
                        }
                    }

                }
            }
            
            class Grass extends Sprite{
                lastSound = 0;
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                }

                isVisible(player, rayIntersections){
                    
                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    if(playerDistance < 0.3){
                        if(performance.now() - this.lastSound > 1000 && (keyInputs.q || keyInputs.e || keyInputs.w || keyInputs.a || keyInputs.s || keyInputs.d)){
                            soundLoader.soundList['bush'].currentTime = 0;
                            soundLoader.soundList['bush'].play();
                            this.lastSound = performance.now();
                        }
                        
                    }
                    super.isVisible(player, rayIntersections);
                }
            }

            

            class Teleporter extends Sprite{
                lastSound = 0;
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                }

                draw(player){
                    if(!this.active) return true;
                    this.ctx.save();
                    this.ctx.fillStyle = "yellow";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 6, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.restore();
                }

                isVisible(player, rayIntersections){
                    if(this.active){
                        let yRelative = ( this.yPos - player.yPos)/gridSize;
                        let xRelative = ( this.xPos - player.xPos)/gridSize;
                        let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                        if(playerDistance < 0.2){
                            if(performance.now() - this.lastSound > 1000 && (keyInputs.q || keyInputs.e || keyInputs.w || keyInputs.a || keyInputs.s || keyInputs.d)){
                                soundLoader.soundList['bush'].play();
                                startingStrawbs = strawbCount;
                                this.lastSound = performance.now();
                                userInterface.startSceneChange();
                            }
                            
                        }
                    }
                    super.isVisible(player, rayIntersections);
                }
            }

            class Splash{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                borderWidth = 4;
                insetWidth = 2;
                isOpen;
                splashImg;
                lastFlash = 0;
                buttonText = "START";
                fontSize = 28;

                constructor(ctx, splashImg){
                    this.ctx = ctx;
                    this.splashImg = splashImg;
                    this.isOpen = true;
                }
                close(){
                    this.ctx.canvas.style.cursor = "auto";
                    this.isOpen = false;
                }
                open(){
                    canvas.style.visibility = "hidden";
                    this.isOpen = true;
                }

                buttonAction(){
                    canvas.style.visibility = "visible";
                    this.close();
                }

                draw(deltaT){

                    if((mouseInput_game.y > this.ctx.canvas.height - 100 && mouseInput_game.click)|| keyInputs[" "]){
                        this.buttonAction();
                        return true;
                    }else{
                        canvas.style.visibility = "hidden";
                    }
                    
                    this.ctx.drawImage(this.splashImg, 0,0,this.ctx.canvas.width, this.ctx.canvas.height);
                    this._drawInsetBox(0,0,this.ctx.canvas.width,100);
                    this.ctx.save();
                    this.ctx.fillStyle = "white";
                    this.ctx.textAlign = "center";
                    this.ctx.font = this.fontSize + "px sans-serif";
                    this.ctx.fillText(this.buttonText, this.ctx.canvas.width/2, this.ctx.canvas.height - 40);
                    if(performance.now() -  this.lastFlash >= 500){
                        if(performance.now() -  this.lastFlash >= 1000){
                        this.lastFlash = performance.now();
                        }
                        this.ctx.fillText(">", this.ctx.canvas.width/2 - 60, this.ctx.canvas.height - 40);
                    }

                    if(mouseInput_game.y > this.ctx.canvas.height - 100){
                        this.ctx.strokeStyle = "white";
                        this.ctx.strokeRect(this.ctx.canvas.width/2 - 100, this.ctx.canvas.height - 75, 200,50);
                        this.ctx.canvas.style.cursor = "pointer";
                    }else{
                        this.ctx.canvas.style.cursor = "auto";
                    }
                    
                    this.ctx.restore();
                }

                //x y relative bottom left
                _drawInsetBox(x,y,width, height){
                    this.ctx.fillStyle = "teal";
                    this.ctx.fillRect(x, y+this.ctx.canvas.height - height, width, height);
                    
                    this.ctx.fillStyle = "grey"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);

                    this.ctx.fillStyle = "white"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - this.borderWidth - this.insetWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+width - 2*this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);
                    
                    this.ctx.fillStyle = "darkSlateGrey";
                    this.ctx.fillRect(x+this.borderWidth + this.insetWidth, y+this.ctx.canvas.height - height + this.borderWidth + this.insetWidth, width - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, height - 2*(this.insetWidth + this.borderWidth));
                    
                }

            }

            class DefeatSplash extends Splash{
                constructor(ctx, splashImg){
                    super(ctx, splashImg);
                    this.buttonText = "CONTINUE";
                    this.fontSize = 20;
                }
                buttonAction(){
                    strawbCount = startingStrawbs;
                    userInterface.sceneChange(0, player, levelCounter);
                    soundLoader.soundList['defeat'].pause();
                    defaultSoundLevels();
                    super.buttonAction();
                }
            }

            class UserInterface{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                faceImg;
                imgLayerBlink;
                imgLayerClose;
                imgLayerBlush;

                netxBlink = 0;
                nextClose = 0;
                blinking = false;
                closed = false;
                faceSize = 100;
                borderWidth = 4;
                insetWidth = 2;
                oldScore = 0;
                blush = false;
                blushStart = 0;
                effectStart = 0;
                effectActive = false;
                health = 100;
                defeatActive = false;

                constructor(ctx, faceImg, blink, closed, blush){
                    this.ctx = ctx;
                    this.faceImg = faceImg;
                    this.imgLayerBlink = blink;
                    this.imgLayerClose = closed;
                    this.imgLayerBlush = blush;
                }

                update(){
                    let now = performance.now();
                    if(now > this.netxBlink){
                        if(this.netxBlink != 0){
                             this.blinking = true;
                        }
                        if(now - this.netxBlink > 500){
                            this.blinking = false;
                            this.netxBlink = now + ((Math.random() * 5000) + 2500);
                            
                        }
                    }

                    if(now > this.nextClose){
                        this.closed = true;
                        if(now - this.nextClose > 4000){
                            if(this.nextClose != 0) this.closed = false;
                            this.nextClose = now + ((Math.random() * 10000) + 5000);
                        }
                    }

                    if(this.blush && now - this.blushStart > 1000 && this.blushStart != 0){
                        this.blush = false;
                        this.blinking = false;
                        this.nextClose = now + ((Math.random() * 5000) + 5000);
                        this.netxBlink = now + ((Math.random() * 5000) + 2500);
                    }else if(now - this.blushStart <= 1000 && this.blushStart != 0){
                        this.blinking = true;
                        this.closed = false;
                    }

                    if(this.oldScore < strawbCount){
                        this.oldScore = strawbCount;
                        this.setBlush();
                        soundLoader.soundList['bleat'].play();
                        this.heal(20);
                        if(sceneScore == sceneGoal){
                            teleporter.active = true;
                        }
                    }
                }
                hit(){
                    this.health = Math.max(0, this.health - 10);
                    if(this.health == 0){
                        if(!userInterface.defeatActive) userInterface.defeat();
                    }else{
                        soundLoader.soundList['bleat_hurt'].currentTime = 0;
                        soundLoader.soundList['bleat_hurt'].play();
                    }
                    
                }
                heal(points){
                    this.health = Math.min(100, this.health + points);
                }

                setBlinking(){
                    this.blinking = true;
                    this.netxtBlink = performance.now();
                }

                setClosed(){
                    this.closed = true;
                    this.nextClose = performance.now();
                }

                setOpen(){
                    this.closed = false;
                    this.nextClose = performance.now() + ((Math.random() * 10000) + 5000);
                }

                setBlush(){
                    this.blush = true;
                    this.blinking = true;
                    this.blushStart = performance.now();
                }
                startSceneChange(){
                    this.effectActive = true;
                    this.effectStart = performance.now();
                }
                sceneChange(deltaT, player, level){
                    let changeDuration = 1000;
                    let now = performance.now();
                    let alpha = (now - this.effectStart)/changeDuration;
                    if(alpha > 1){
                        alpha = 1;
                        if(now - this.effectStart > 2000){
                            if(level !== null){
                                levelCounter = level;
                            }else{
                                levelCounter++;
                            }
                            if(levelCounter >= mapLevels.length) levelCounter = 0;
                            mapFromCode(mapLevels[levelCounter]);
                            generateWorld();
                            generateMapCode();
                            player.xPos = 256;
                            player.yPos = 256;
                            this.effectStart = 0;
                            this.effectActive = 0;
                        }
                    }
                    this.ctx.save();
                    this.ctx.fillStyle = "rgba(0,0,0,"+alpha.toFixed(2)+")";
                    this.ctx.fillRect(0,0,this.ctx.canvas.width, this.ctx.canvas.height);
                    this.ctx.fillStyle = "rgba(255,255,255,"+alpha.toFixed(2)+")";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "bold 32px sans-serif"
                    this.ctx.fillText("Zzzz...",255,255);
                    this.ctx.restore();
                }
                defeat(){
                    this.effectActive = true;
                    this.effectStart = performance.now();
                    this.defeatActive = true;
                    
                    for(const sound in soundLoader.soundList){
                        soundLoader.soundList[sound].volume = 0.4;
                    }
                    soundLoader.soundList['defeat'].volume = 1;
                    soundLoader.soundList['defeat'].play();
                }
                _defeat(){
                    let changeDuration = 1000;
                    let now = performance.now();
                    let alpha = (now - this.effectStart)/changeDuration;


                    for(const sound in soundLoader.soundList){
                        if(sound != 'defeat') soundLoader.soundList[sound].volume = Math.max(0, 0.4 - (0.4 * alpha));
                    }

                    if(alpha > 1){
                        alpha = 1;
                        if(now - this.effectStart > 2000){
                            splashScreen = new DefeatSplash(ctxCamera, textureLoader.imageList['defeat_splash']);
                            this.defeatActive = false;
                            return false;
                        }
                    }

                    
                    this.ctx.save();
                    this.ctx.fillStyle = "rgba(0,0,0,"+alpha.toFixed(2)+")";
                    this.ctx.fillRect(0,0,this.ctx.canvas.width, this.ctx.canvas.height);
                    this.ctx.fillStyle = "rgba(255,255,255,"+alpha.toFixed(2)+")";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "bold 32px sans-serif"
                    this.ctx.fillText("CAPTURED",255,255);
                    
                    this.ctx.restore();
                }

                _drawReadyNest(){
                    this.ctx.save();
                    this._drawInsetBox(this.ctx.canvas.width/2 - 100,50-this.ctx.canvas.height,200, 50);
                    this.ctx.fillStyle = "white";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "bold 20px sans-serif"
                    this.ctx.fillText("Ready to nest",255,32);
                    this.ctx.restore();
                } 

                _drawRemaining(){
                    this.ctx.save();
                    this._drawInsetBox(0,0-this.faceSize, this.faceSize, 25);
                    this.ctx.fillStyle = "grey";
                    this.ctx.textAlign = "center";
                    this.ctx.font = "12px sans-serif"
                    this.ctx.fillText((sceneGoal - sceneScore)+" to go",this.faceSize/2,this.ctx.canvas.height - this.faceSize - 8);
                    this.ctx.restore();
                }

                _drawFaceFrame(){
                    //face frame
                    this.ctx.save();
                    this._drawInsetBox(0,0,this.faceSize, this.faceSize)
                    this.ctx.drawImage(this.faceImg, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))

                    if(this.blinking){
                        this.ctx.drawImage(this.imgLayerBlink, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }
                    if(this.closed){
                        this.ctx.drawImage(this.imgLayerClose, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }

                    if(this.blush){
                        this.ctx.drawImage(this.imgLayerBlush, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }


                    this.ctx.restore();
                }

                //x y relative bottom left
                _drawInsetBox(x,y,width, height){
                    this.ctx.fillStyle = "teal";
                    this.ctx.fillRect(x, y+this.ctx.canvas.height - height, width, height);
                    
                    this.ctx.fillStyle = "grey"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);

                    this.ctx.fillStyle = "white"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - this.borderWidth - this.insetWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+width - 2*this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);
                    
                    this.ctx.fillStyle = "darkSlateGrey";
                    this.ctx.fillRect(x+this.borderWidth + this.insetWidth, y+this.ctx.canvas.height - height + this.borderWidth + this.insetWidth, width - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, height - 2*(this.insetWidth + this.borderWidth));
                    
                }

                _drawScore(){
                    let scoreBox = 50;
                    this.ctx.save();
                    this._drawInsetBox(this.faceSize, 0, scoreBox, scoreBox)
                    this.ctx.font = "bold 28px sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillStyle = "white";
                    this.ctx.fillText(strawbCount, this.faceSize + this.borderWidth + this.insetWidth + (scoreBox - 2*(this.borderWidth + this.insetWidth))/2, this.ctx.canvas.height - (2*this.borderWidth + this.insetWidth) - 4);
                    this.ctx.restore();
                }

                _drawHealth(){
                    let scoreBox = 50;
                    this.ctx.save();
                    this._drawInsetBox(this.faceSize, 0 - scoreBox - scoreBox, scoreBox, 25);
                    this.ctx.font = "12px sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillStyle = "white";
                    this.ctx.fillText(this.health,this.faceSize + this.borderWidth + this.insetWidth + (scoreBox - 2*(this.borderWidth + this.insetWidth))/2,this.ctx.canvas.height - this.faceSize - 8);

                    this.ctx.restore();
                }

                _nearestArrow(player){
                    let closestIndex = 0;
                    let closestDistance = Infinity;
                    for(var i = 0; i < spriteList.length; i++){
                        if(spriteList[i] instanceof StrawberrySprite && spriteList[i].active){
                            let thisDistance = Math.abs(spriteList[i].xPos - player.xPos) + Math.abs(spriteList[i].yPos - player.yPos);
                            if(closestDistance > thisDistance){
                                closestDistance = thisDistance;
                                closestIndex = i;
                            }
                        }
                    }
                    let dx = spriteList[closestIndex].xPos - player.xPos
                    let dy = spriteList[closestIndex].yPos - player.yPos
                    let hp = Math.sqrt(Math.pow(dy,2) + Math.pow(dx, 2));

                    dx = dx/hp;
                    dy = dy/hp;

                    let dot = dy * player.directionY + dx * player.directionX;
                    let cross = dx * player.directionY - dy * player.directionX;
                     
                    let nearestAngle = -1*(Math.PI/2 * cross) - Math.PI/2
                    if(dot < 0) nearestAngle = (nearestAngle) *-1;
                    let scoreBox = 50;
                    this.ctx.save();
                    this._drawInsetBox(this.faceSize, 0-scoreBox, scoreBox, scoreBox)
                    this.ctx.beginPath();
                    this.ctx.fillStyle = "grey";
                    let arcX = this.faceSize + this.borderWidth + this.insetWidth + (scoreBox - 2*(this.borderWidth + this.insetWidth))/2 -1;
                    let arcY = this.ctx.canvas.height - (scoreBox/2) - scoreBox;
                    this.ctx.arc(arcX, arcY, 16, 0, 2*Math.PI);
                    this.ctx.fill();
                    if(sceneScore == sceneGoal){
                        this.ctx.fillStyle = "yellow";
                    }else{
                        this.ctx.fillStyle = "red";
                    }
                    this.ctx.beginPath();
                    this.ctx.moveTo(arcX,arcY);
                    this.ctx.lineTo(arcX + Math.cos(nearestAngle - (Math.PI/8)) * 16, arcY+ Math.sin(nearestAngle - (Math.PI/8)) * 16);
                    this.ctx.arc(arcX, arcY, 16, nearestAngle - (Math.PI/8), nearestAngle + (Math.PI/8));
                    this.ctx.lineTo(arcX,arcY);
                    this.ctx.fill();
                    this.ctx.restore();
                }

                _drawKeys(){
                    let typeCount = 0;
                    for(const type in keyCount){
                        switch(type){
                            case '1':
                                var keyImg = "key";
                            break;
                            case '2':
                                var keyImg = "key_silver";
                            break;
                            case '3':
                                var keyImg = "key_bronze";
                            break;
                        }
                        for(var i = 0; i < keyCount[type]; i++){
                            this.ctx.drawImage(textureLoader.imageList[keyImg], this.faceSize - 40 + (i*4), this.ctx.canvas.height - 60 + (i*4) + (typeCount*8), 40,40);
                        }
                        typeCount++;
                    }
                }

                draw(deltaT, player){
                    this._drawFaceFrame();
                    this._drawScore();
                    this._drawHealth();
                    this._drawRemaining()
                    this._nearestArrow(player);
                    if(sceneScore == sceneGoal){
                        this._drawReadyNest();
                    }
                    
                    this._drawKeys();
                    
                    if(this.effectActive){
                        if(this.defeatActive){
                            this._defeat();
                        }else{
                            this.sceneChange(deltaT, player, null);
                        }
                    }
                }
            }

            class StrawberrySprite extends Sprite{
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                    if(this.active){
                        let yRelative = ( this.yPos - player.yPos)/gridSize;
                        let xRelative = ( this.xPos - player.xPos)/gridSize;
                        let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                        if(playerDistance < 0.3){
                            strawbCount += 1;
                            sceneScore += 1;
                            this.active = false;
                        }
                    }
                }

                draw(player){
                    if(!this.active) return true;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        this.ctx.fillStyle = "red";
                        this.ctx.beginPath();
                        this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
            }

            class TreeSprite extends Sprite{
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked = true;
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blockedBy = this;
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                }

                draw(player){
                    if(!this.active) return true;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        this.ctx.fillStyle = "green";
                        this.ctx.beginPath();
                        this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
            }

            class RobotSprite extends Sprite{
                lastFire = 0;
                fireRate = 3000;
                lastAlert = 0;
                alertDelay = 1000;
                sound;

                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                    this.directionX = 0;
                    this.directionY = 0;
                    this.hopLength = 15;
                    this.hopProgress = 0;
                    this.speed = 5;
                    this.isMoving = false;
                    this.health = 3;
                    this.isAlive = true;
                    this.alertDelay += Math.round(Math.random() * 2000);
                    this.sound = soundLoader.soundList['alarm'].cloneNode();
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                }
                _chooseDirection(){
                    let direction = Math.random() * 2*Math.PI;
                    this.directionY = Math.sin(direction);
                    this.directionX = Math.cos(direction);
                }
                pickHop(){
                    this._chooseDirection();
                    let tryCount = 0;
                    while(tryCount < 25){
                        let hopDestX = (this.xPos + (this.directionX*this.hopLength))/gridSize;
                        let hopDestY = (this.yPos + (this.directionY*this.hopLength))/gridSize;
                        if(hopDestX < 0 || hopDestY < 0 || hopDestX > dataSquares.length || hopDestY > dataSquares.length || dataSquares[Math.floor(hopDestX)][Math.floor(hopDestY)].blocked || gridSquares[Math.floor(hopDestX)][Math.floor(hopDestY)]){
                            tryCount++;
                            this._chooseDirection();
                        }else{
                            break;
                        }
                    }
                    this.hopProgress = 0;
                    this.isMoving = true;
                }
                hit(){
                    this.health -= 1;
                    if(this.health <= 0 ){
                        this.isAlive = false;
                    }
                }
                update(deltaT){
                    if(!this.isAlive) return true;
                    if(this.isMoving == false){
                        this.pickHop();
                    }
                    
                    let frameDistance = this.speed*(deltaT/1000);

                    if(!this.isAlert && this.hopProgress + frameDistance > this.hopLength){
                        frameDistance = this.hopLength - this.hopProgress;
                        this.isMoving = false;
                    }
                    this.hopProgress += frameDistance;
                    
                    let nextX = this.xPos + (this.directionX*frameDistance);
                    let nextY = this.yPos + (this.directionY*frameDistance);
                    
                    if(dataSquares[Math.floor(nextX/gridSize)][Math.floor(nextY/gridSize)].blocked || gridSquares[Math.floor(nextX/gridSize)][Math.floor(nextY/gridSize)]){
                        this.isMoving = false;
                    }else{
                        this.xPos = nextX;
                        this.yPos = nextY;
                    }
                }

                fire(){
                    var now = performance.now();
                    if(this.lastFire + this.fireRate <= now){
                        this.lastFire = now;
                        let bulletOffset = 4;
                        let newBullet = new BulletSprite(ctx, textureLoader.imageList['net'], this.xPos + (bulletOffset * this.directionX), this.yPos + (bulletOffset * this.directionY), 0, gridSize, gridSize, netImageRotation)
                        newBullet.targetsPlayers = true;
                        newBullet.speed = 80;
                        newBullet.directionX = this.directionX;
                        newBullet.directionY = this.directionY;
                        spriteList.push(newBullet);
                    }
                }

                draw(player){

                    let playerAngle = Math.atan2(this.yPos - player.yPos, this.xPos - player.xPos);
                    let py = Math.sin(playerAngle);
                    let px = Math.cos(playerAngle);

                    let dot = this.directionY * py + this.directionX * px;
                    let cross = this.directionX * py - this.directionY * px;
                    
                    if(this.isAlive){
                        if(dot < 0){
                            let playerAngle2 = Math.atan2(player.yPos - this.yPos, player.xPos - this.xPos);
                            //check if it can see the player
                            //start and end points in grid space
                            let startCellX = this.xPos/gridSize;
                            let startCellY = this.yPos/gridSize;

                            let yRelative = ( this.yPos - player.yPos)/gridSize;
                            let xRelative = ( this.xPos - player.xPos)/gridSize;
                            let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));

                            let intersect = castRay(playerAngle2, startCellX, startCellY);

                            if(intersect && intersect.rayLength < playerDistance){
                                this.isAlert = false;
                            }else{
                                if(!this.isAlert){
                                    this.lastAlert = performance.now();
                                    this.sound.volume = 0.1 +   Math.max(0, (0.9 * (1-(playerDistance/15))))
                                    this.sound.play();
                                }
                                
                                this.isAlert = true;
                                
                                this.directionY = Math.sin(playerAngle2);
                                this.directionX = Math.cos(playerAngle2);
                            }

                            this.image = textureLoader.imageList['robo'];

                            if(this.isAlert && (this.lastAlert + this.alertDelay < performance.now())){
                                this.fire();
                            }
                            
                        }else{
                            this.image = textureLoader.imageList['robo_back'];
                            this.isAlert = false;
                        }
                    }else{
                        if(dot < 0){
                            this.image = textureLoader.imageList['robo_destroyed']
                        }else{
                            this.image = textureLoader.imageList['robo_back_destroyed']
                        }
                    }

                    if(!this.active) return true;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        if(this.isAlert){
                            this.ctx.fillStyle = "orange";
                        }else{
                            this.ctx.fillStyle = "blue";
                        }
                        this.ctx.beginPath();
                        this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
            }

            class BunnySprite extends Sprite{
                
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                    this.directionX = 0;
                    this.directionY = 0;
                    this.hopLength = 15;
                    this.hopProgress = 0;
                    this.speed = 1;
                    this.isMoving = false;
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                }
                _chooseDirection(){
                    let direction = Math.random() * 2*Math.PI;
                    this.directionY = Math.sin(direction);
                    this.directionX = Math.cos(direction);
                }
                pickHop(){
                    this._chooseDirection();
                    while(true){
                        let hopDestX = (this.xPos + (this.directionX*this.hopLength))/gridSize;
                        let hopDestY = (this.yPos + (this.directionY*this.hopLength))/gridSize;
                        if(hopDestX < 0 || hopDestY < 0 || hopDestX > dataSquares.length || hopDestY > dataSquares.length || dataSquares[Math.floor(hopDestX)][Math.floor(hopDestY)].blocked || gridSquares[Math.floor(hopDestX)][Math.floor(hopDestY)]){
                            this._chooseDirection()
                        }else{
                            break;
                        }
                    }
                    this.hopProgress = 0;
                    this.isMoving = true;
                }
                update(deltaT){
                    if(this.isMoving == false){
                        this.pickHop();
                    }

                    let extraSpeed = 15 * (1-(this.hopProgress/this.hopLength));
                    

                    let frameDistance = (this.speed + extraSpeed)*(deltaT/1000);

                    if(this.hopProgress + frameDistance > this.hopLength){
                        frameDistance = this.hopLength - this.hopProgress;
                        this.isMoving = false;
                    }
                    this.hopProgress += frameDistance;
                    this.xPos += (this.directionX*frameDistance);
                    this.yPos += (this.directionY*frameDistance);
                    if(dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked || gridSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)]){
                        this.isMoving == false;
                    }
                }

                draw(player){

                    let playerAngle = Math.atan2(this.yPos - player.yPos, this.xPos - player.xPos);
                    let py = Math.sin(playerAngle);
                    let px = Math.cos(playerAngle);

                    let dot = this.directionY * py + this.directionX * px;
                    let cross = this.directionX * py - this.directionY * px;
                     
                    if(dot < 0){
                        this.image = textureLoader.imageList['bunny']
                    }else{
                        this.image = textureLoader.imageList['bunny_back']
                    }

                    if(!this.active) return true;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        this.ctx.fillStyle = "pink";
                        this.ctx.beginPath();
                        this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
            }

            class KeySprite extends Sprite{
                type;
                constructor(ctx, image, xPos, yPos, zPos, width, height, type){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                    this.type = type;
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                    if(this.active){
                        let yRelative = ( this.yPos - player.yPos)/gridSize;
                        let xRelative = ( this.xPos - player.xPos)/gridSize;
                        let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                        if(playerDistance < 0.3){
                            if(!keyCount[this.type]) keyCount[this.type] = 0;
                            keyCount[this.type] += 1;
                            this.active = false;
                            soundLoader.soundList['key'].play();
                        }
                    }
                }

                draw(player){
                    if(!this.active) return true;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        switch(this.type){
                            case 1:
                                this.ctx.fillStyle = "gold";
                            break;
                            case 2:
                                this.ctx.fillStyle = "silver";
                            break;
                            case 3:
                                this.ctx.fillStyle = "#CD7F32";
                            break;
                        }
                        
                        this.ctx.beginPath();
                        this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                }
            }

            class BulletSprite extends Sprite{
                speed = 200;
                rSpeed = 180;
                animatedImg = [];
                roll = 0;
                hitTime = 0;
                hitLength = 200;
                isHit = false;
                targetsPlayers = false;
                
                constructor(ctx, image, xPos, yPos, zPos, width, height, animatedImg){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                    this.animatedImg = animatedImg;
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                }

                update(deltaT){
                    if(this.isHit){
                        if(performance.now() - this.hitTime >= this.hitLength){
                            this.deleteSprite();
                        }
                    }else{
                        let distance = this.speed*deltaT/1000;
                        let nextXPos = this.xPos + this.directionX * distance;
                        let nextYPos = this.yPos + this.directionY * distance;
                        let gridX = Math.floor(nextXPos/gridSize);
                        let gridY = Math.floor(nextYPos/gridSize);
                        let hitRadius = gridSize/4;

                        if(Math.abs(player.xPos - nextXPos) < (hitRadius) && Math.abs(player.yPos - nextYPos) < (hitRadius)){
                            this.hit();
                            userInterface.hit();
                            return true;
                        }

                        if(gridSquares[gridX] && gridSquares[gridX][gridY]){
                            this.hit();
                            return true;
                        }

                        if(dataSquares[gridX] && dataSquares[gridX][gridY] && dataSquares[gridX][gridY].blocked){
                            if(dataSquares[gridX][gridY].blockedBy instanceof DoorSprite){
                                this.hit();
                                return true;
                            } else if(Math.abs((gridX*gridSize + (gridSize/2)) - nextXPos) < (hitRadius) && Math.abs((gridY*gridSize + (gridSize/2)) - nextYPos) < (hitRadius)){
                                this.hit();
                                return true;
                            }
                        }

                        
                        for(var i = 0 ; i < spriteList.length; i++){
                            if(spriteList[i]){
                                if(Math.abs(spriteList[i].xPos - nextXPos) < (hitRadius) && Math.abs(spriteList[i].yPos - nextYPos) < (hitRadius)){
                                    if(spriteList[i] instanceof BunnySprite){
                                        this.hit();
                                        return true;
                                    }else if(spriteList[i] instanceof RobotSprite){
                                        spriteList[i].hit();
                                        this.hit();
                                        return true;
                                    }
                                }
                            }
                        }


                        this.xPos = nextXPos;
                        this.yPos = nextYPos;

                        this.roll += this.rSpeed * deltaT/1000;
                        if(this.roll > 360) this.roll -= 360;
                        
                        this.image = this.animatedImg[Math.floor((this.animatedImg.length-1) * (this.roll/360))];

                        

                        //left the play field
                        if(gridX < 0 || gridX > gridSquares.length || gridY < 0 || gridY > gridSquares[0].length){
                            this.deleteSprite();
                        }
                    }
                }

                hit(){
                    this.hitTime = performance.now();
                    soundLoader.soundList['hit'].currentTime = 0;
                    soundLoader.soundList['hit'].play();
                    this.isHit = true;
                    this.image = textureLoader.imageList['hit'];
                }

                draw(player){
                    if(!this.active) return true;
                }
            }

            class DoorSprite extends Sprite{
                direction;
                open = false;
                openImg;
                closedImg;
                type;
                constructor(ctx, openImg, closedImg, xPos, yPos, width, height, direction, type){
                    super(ctx, closedImg, xPos, yPos, 0, width, height);
                    this.direction = direction;
                    this.openImg = openImg;
                    this.closedImg = closedImg;
                    this.type = type;
                    //block own square
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked = true;
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blockedBy = this;
                }

                deleteSprite(){
                    let gridX = Math.floor(this.xPos/gridSize);
                    let gridY = Math.floor(this.yPos/gridSize);
                    this.active = false;
                    dataSquares[gridX][gridY].blocked = false;
                    dataSquares[gridX][gridY].blockedBy = null;
                    super.deleteSprite()
                }
                setOpen(){
                    this.open = true;
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked = false;
                    this.image = this.openImg;
                }

                setClosed(){
                    this.open = false;
                    dataSquares[Math.floor(this.xPos/gridSize)][Math.floor(this.yPos/gridSize)].blocked = true;
                    this.image = this.closedImg;
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    if(playerDistance < 0.6 && keyCount[this.type] > 0 && !this.open){
                        keyCount[this.type] -= 1;
                        this.setOpen();
                        soundLoader.soundList['unlock'].play();
                        soundLoader.soundList['bleat'].play();
                    }
                }

                

                draw(player){
                    if(!this.active) return false;
                    if(this.seen || MAP_EDIT_MODE){
                        this.ctx.save();
                        switch(this.type){
                            case 1:
                                this.ctx.strokeStyle = "gold";
                            break;
                            case 2:
                                this.ctx.strokeStyle = "silver";
                            break;
                            case 3:
                                this.ctx.strokeStyle = "#CD7F32";
                            break;
                        }
                        this.ctx.lineWidth = 4;
                        this.ctx.beginPath();
                        if(this.direction == 'x'){ //blocking the x direction
                            
                            this.ctx.moveTo(this.xPos, this.yPos - gridSize/2);
                            this.ctx.lineTo(this.xPos, this.yPos + gridSize/2);
                        }else{
                            
                            this.ctx.moveTo(this.xPos - gridSize/2, this.yPos);
                            this.ctx.lineTo(this.xPos + gridSize/2, this.yPos);
                        }
                        this.ctx.stroke();
                        this.ctx.restore();
                    }
                }
            }

            class Player{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                xPos;
                yPos;
                speed = 80;
                rSpeed = 200;
                directionX = 1;
                directionY = 0;
                lastFire = 0;
                fireRate = 250;

                constructor(ctx, xPos, yPos){
                    this.ctx = ctx;
                    this.xPos = xPos;
                    this.yPos = yPos;
                }
                draw(){
                    this.ctx.save()
                    this.ctx.fillStyle = "green";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "yellow";
                    this.ctx.lineWidth = 4;
                    this.ctx.moveTo(this.xPos, this.yPos);
                    this.ctx.lineTo(this.xPos + this.directionX*10, this.yPos + this.directionY*10);
                    this.ctx.stroke();
                    this.ctx.restore();
                }
                animate(deltaT){
                    let dy = 0;
                    let dx = 0;
                    var nextY = this.yPos;
                    var nextX = this.xPos;

                    

                    if(keyInputs.e || keyInputs.q){
                        
                        let viewAngle = Math.atan2(this.directionY, this.directionX);

                        let moveAngle = (Math.PI/2);

                        if(keyInputs.w){
                            moveAngle =  (Math.PI/4);
                            if(keyInputs.q){
                                moveAngle = (Math.PI/2)  +  (Math.PI/4);
                            }
                        }
                        if(keyInputs.s){
                            moveAngle = -1 * (Math.PI/4) + (Math.PI/2) ;
                            if(keyInputs.e){
                                moveAngle = (Math.PI/2)  +  (Math.PI/4);
                            }
                        }


                        let newAngle = viewAngle + moveAngle; //some number of radians
                        let strafeY = Math.sin(newAngle);
                        let strafeX = Math.cos(newAngle);
                        let strafeDy = 0;
                        if(keyInputs.q){
                            strafeDy += this.speed * deltaT/1000;
                            
                        }
                        if(keyInputs.e){
                            strafeDy -= this.speed * deltaT/1000;
                        }

                        nextY = this.yPos - strafeY*strafeDy;
                        nextX = this.xPos - strafeX*strafeDy;
                        
                    }else{
                        if(keyInputs.w){
                            dy -= this.speed * deltaT/1000;
                        }
                        if(keyInputs.s){
                            dy += this.speed * deltaT/1000;
                        }
                    }

                    if(keyInputs.a){
                        dx -= this.rSpeed * deltaT/1000;
                    }

                    if(keyInputs.d){
                        dx += this.rSpeed * deltaT/1000;
                    }

                    

                    if(dx != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        let newAngle = viewAngle + ( dx * 0.0174533); //some number of radians
                        this.directionY = Math.sin(newAngle);
                        this.directionX = Math.cos(newAngle);
                    }

                    if(dy != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        nextY = this.yPos - Math.sin(viewAngle)*dy;
                        nextX = this.xPos - Math.cos(viewAngle)*dy;
                    }

                    let nextGridY = Math.floor(nextY/gridSize);
                    let nextGridX = Math.floor(nextX/gridSize);

                    if(gridSquares[nextGridX] && !gridSquares[nextGridX][nextGridY] && !dataSquares[nextGridX][nextGridY].blocked){
                        this.yPos = nextY;
                        this.xPos = nextX;
                    }

                    this.yPos = Math.max(this.yPos, 0);
                    this.yPos = Math.min(this.yPos, ctx.canvas.height);

                    this.xPos = Math.max(this.xPos, 0);
                    this.xPos = Math.min(this.xPos, ctx.canvas.width);


                    if(keyInputs[' '] && !splashScreen.isOpen){
                        var now = performance.now();
                        if(this.lastFire + this.fireRate <= now){
                            this.lastFire = now;
                            let bulletOffset = 4;
                            let newBullet = new BulletSprite(ctx, textureLoader.imageList['bullet'], this.xPos + (bulletOffset * this.directionX), this.yPos + (bulletOffset * this.directionY), 0, gridSize, gridSize, bulletImageRotation)
                            newBullet.directionX = this.directionX;
                            newBullet.directionY = this.directionY;
                            spriteList.push(newBullet);
                            hoof.shoot();
                        }
                    }
                }
            }

            hoof = new Hoof(ctxCamera);

            player = new Player(ctx, 256, 256);
            rayIntersections = {};


            function drawMouse(ctx){
                if(MAP_EDIT_MODE){
                    ctx.save()
                    ctx.fillStyle = "teal";
                    ctx.beginPath();
                    ctx.arc(Math.round(mouseInput.x), Math.round(mouseInput.y), 4, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            function paintSquares(mouseInput, gridSize){
                if((mouseInput.click || mouseInput.altClick || mouseInput.middleClick) && MAP_EDIT_MODE){
                    let gridX = Math.floor(mouseInput.x/gridSize);
                    let gridY = Math.floor(mouseInput.y/gridSize);

                    let button = 0;
                    if(mouseInput.click){
                        button = 0;
                    }else if(mouseInput.altClick){
                        button = 2;
                    }else if(mouseInput.middleClick && keyInputs.Shift){
                        button = 3;
                    }else if(mouseInput.middleClick){
                        button = 1;
                    }

                    if(gridX < gridSquares.length){
                        if(gridY < gridSquares[gridX].length){
                            

                            //only do each action once per square unless user mouse ups
                            if(lastMouseAction.gridX != gridX || lastMouseAction.gridY != gridY || lastMouseAction.button != button){

                                //grid wall operations remove sprites
                                if(mouseInput.click || mouseInput.altClick){
                                    for(var i = 0 ; i < spriteList.length; i++){
                                        if(spriteList[i]){
                                            if(Math.floor(spriteList[i].xPos/gridSize) == gridX && Math.floor(spriteList[i].yPos/gridSize) == gridY){
                                                spriteList[i].deleteSprite();
                                            }
                                        }
                                    }
                                }
                                if(mouseInput.click && keyInputs.b){
                                    spriteList.push(new BunnySprite(ctx, textureLoader.imageList['bunny'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, 1));
                                }else if(mouseInput.click && keyInputs.r){
                                    spriteList.push(new RobotSprite(ctx, textureLoader.imageList['robo'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, 1));
                                }else if(mouseInput.click && keyInputs.t){
                                    spriteList.push(new TreeSprite(ctx, textureLoader.imageList['tree'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, 1));
                                }else if(mouseInput.click){
                                    gridSquares[gridX][gridY] = true;
                                }else if(mouseInput.altClick){
                                    gridSquares[gridX][gridY] = false;
                                }else if(mouseInput.middleClick && keyInputs.Shift){
                                    let keyFound = false;
                                    for(var i = 0 ; i < spriteList.length; i++){
                                        if(spriteList[i]){
                                            if(Math.floor(spriteList[i].xPos/gridSize) == gridX && Math.floor(spriteList[i].yPos/gridSize) == gridY){
                                                if(spriteList[i] instanceof KeySprite){
                                                    switch(spriteList[i].type){
                                                        case 1:
                                                            spriteList[i].type = 2;
                                                            spriteList[i].image = textureLoader.imageList['key_silver'];
                                                        break;
                                                        case 2:
                                                            spriteList[i].type = 3;
                                                            spriteList[i].image = textureLoader.imageList['key_bronze'];
                                                        break;
                                                        case 3:
                                                            spriteList[i].type = 1;
                                                            spriteList[i].image = textureLoader.imageList['key'];
                                                        break;
                                                    }
                                                    keyFound = true;
                                                }
                                            }
                                        }
                                    }
                                    if(!keyFound){
                                        spriteList.push(new KeySprite(ctx, textureLoader.imageList['key'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, 1));
                                    }
                                }else if(mouseInput.middleClick){
                                    //swap direction on repeats
                                    if(dataSquares[gridX][gridY].blockedBy instanceof DoorSprite){
                                        if(dataSquares[gridX][gridY].blockedBy.direction == 'x'){
                                            dataSquares[gridX][gridY].blockedBy.direction = 'y';
                                        }else{
                                            dataSquares[gridX][gridY].blockedBy.direction = 'x';
                                            if(dataSquares[gridX][gridY].blockedBy.type < 3){
                                                dataSquares[gridX][gridY].blockedBy.type += 1;
                                            }else{
                                                dataSquares[gridX][gridY].blockedBy.type = 1;
                                            }
                                            switch(dataSquares[gridX][gridY].blockedBy.type){
                                                case 1:
                                                    dataSquares[gridX][gridY].blockedBy.image =  textureLoader.imageList['door'];
                                                break;
                                                case 2:
                                                    dataSquares[gridX][gridY].blockedBy.image =  textureLoader.imageList['door_silver'];
                                                break;
                                                case 3:
                                                    dataSquares[gridX][gridY].blockedBy.image =  textureLoader.imageList['door_bronze'];
                                                break;
                                            }
                                        }
                                    }else{
                                        spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', 1));
                                    }
                                    
                                }
                                lastMouseAction.gridX = gridX;
                                lastMouseAction.gridY = gridY;
                                lastMouseAction.button = button;
                            }
                        }
                    }
                    generateMapCode();
                }
            }

            function compareDistance(a,b){
                if ( a.distance > b.distance ){
                    return -1;
                }
                if ( a.distance < b.distance ){
                    return 1;
                }
                return 0;
            }

            function drawCamera(ctxCamera, rayIntersections){
                ctxCamera.save();
                let skygrad = ctxCamera.createLinearGradient(0, ctxCamera.canvas.height/4, 0, ctxCamera.canvas.height/2);
                skygrad.addColorStop(0, "skyblue");
                skygrad.addColorStop(1, "white");

                ctxCamera.fillStyle = "skyblue";
                ctxCamera.fillRect(0,0,ctxCamera.canvas.width,ctxCamera.canvas.height/2);

                ctxCamera.fillStyle = skygrad;
                ctxCamera.fillRect(0,ctxCamera.canvas.height/4,ctxCamera.canvas.width,ctxCamera.canvas.height/4);

                let groundGrad = ctxCamera.createLinearGradient(0, ctxCamera.canvas.height/2, 0, ctxCamera.canvas.height*0.75);
                groundGrad.addColorStop(0, "#628251");
                groundGrad.addColorStop(1, "#7ca666");

                ctxCamera.fillStyle = "#7ca666";
                ctxCamera.fillRect(0,ctxCamera.canvas.height/2,ctxCamera.canvas.width,ctxCamera.canvas.height/2);

                ctxCamera.fillStyle = groundGrad;
                ctxCamera.fillRect(0,ctxCamera.canvas.height/2,ctxCamera.canvas.width,ctxCamera.canvas.height/4);
                //draw walls
                for(var i = 0; i < resolution; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(rayIntersections[i] && rayIntersections[i].intersects){
                        let height =  256 * (1/rayIntersections[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;
                        ctxCamera.drawImage(textureLoader.imageList[rayIntersections[i].texture], rayIntersections[i].textureCoordinate, 0, 1, textureLoader.imageList[rayIntersections[i].texture].height, i*width, yOffset, width, height)
                    }
                }

                spriteRenders.sort(compareDistance);

                for(var i = 0; i < spriteRenders.length; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(spriteRenders[i]){
                        let height =  256 * (1/spriteRenders[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;

                        ctxCamera.drawImage(spriteRenders[i].texture, spriteRenders[i].textureCoordinate, 0, 1, spriteRenders[i].texture.height, spriteRenders[i].pixel*width, yOffset, width, height)
                        
                    }
                }
                

                ctxCamera.restore();
            }

            //main update loop
            function play(deltaT){
                var frameStart = performance.now();
                if(splashScreen.isOpen){
                    splashScreen.draw();
                }else{
                    spriteRenders = [];
                    for(var i = 0; i < spriteList.length; i++){
                        if(spriteList[i] && spriteList[i].delete){
                            spriteList[i] = null;
                        }
                    }
                    generateGrid(gridSize);
                    paintSquares(mouseInput, gridSize);
                    drawSquares(ctx, gridSize);
                    drawMouse(ctx);
                    player.animate(deltaT);
                    player.draw();
                    rayCastView(ctx, player);
                    for(var i = 0; i < spriteList.length; i++){
                        if(spriteList[i]){
                            spriteList[i].update(deltaT);
                            spriteList[i].draw(player);
                            spriteList[i].isVisible(player, rayIntersections);
                        }
                    }
                    drawCamera(ctxCamera, rayIntersections);
                    hoof.animate(deltaT);
                    hoof.draw();

                    userInterface.update();
                    userInterface.draw(deltaT, player);

                    if(keyInputs.m != true && !MAP_EDIT_MODE){
                        ctx.fillStyle = "#333";
                        ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
                        ctx.fillStyle = "grey";
                        ctx.font = "bold 32px sans-serif";
                        ctx.textAlign = "center";
                        ctx.fillText("Hold m for map..", ctx.canvas.width/2, ctx.canvas.height/2);
                        ctx.font = "bold 16px sans-serif";
                        ctx.fillText("(if you get lost)", ctx.canvas.width/2, ctx.canvas.height/2 + 32);
                    }
                }
                window.requestAnimationFrame(function(){
                    play(performance.now() - frameStart);
                });
            }


            //check for intersections with walls
            //start and end in grid space
            function castRay(viewAngle, startCellX, startCellY){
                let dx = Math.cos(viewAngle);
                let dy = Math.sin(viewAngle);

                let xRay = 0;
                let yRay = 0;

                //scaling factor step size
                let sx =  Math.sqrt(1 + Math.pow(dy/dx,2));
                let sy = Math.sqrt(1 + Math.pow(dx/dy,2));

                let tileCheckX = Math.floor(startCellX);
                let tileCheckY = Math.floor(startCellY);

                //step directions
                let xStep;
                if(dx < 0){
                    xStep = -1;
                    xRay = (startCellX - tileCheckX) * sx;
                }else{
                    xStep = 1;
                    xRay = (tileCheckX + 1 - startCellX) * sx;
                }
                
                let yStep;
                if(dy < 0){
                    yStep = -1;
                    yRay = (startCellY - tileCheckY) * sy;
                }else{
                    yStep = 1;
                    yRay = (tileCheckY + 1 - startCellY) * sy;
                }

                let tileFound = false;
                let rayLength = 0;
                let side;
                while(!tileFound && rayLength < 512){
                    if(xRay < yRay){
                        tileCheckX += xStep;
                        rayLength = xRay;
                        xRay += sx;
                        side = "x";
                    }else{
                        tileCheckY += yStep;
                        rayLength = yRay;
                        yRay += sy;
                        side = "y";
                    }

                    if(tileCheckX >= 0 &&  tileCheckY >= 0 && tileCheckX < gridSquares.length && tileCheckY < gridSquares[tileCheckX].length){
                        if(gridSquares[tileCheckX][tileCheckY]){
                            tileFound = true;
                        }
                    }
                }

                return {
                    tileFound:tileFound,
                    dx:dx,
                    dy:dy,
                    rayLength:rayLength,
                    side:side
                }
            }

            function rayCastView(ctx, player){

                //start and end points in grid space
                let startCellX = player.xPos/gridSize;
                let startCellY = player.yPos/gridSize;

                //unit vector
                let dx = player.directionX;
                let dy = player.directionY;
                let viewAngle = Math.atan2(dy, dx);
                
                for(var i = -1*halfRes; i <= halfRes; i++){
                    let offset = (Math.PI/2)/resolution;
                    let newAngle = viewAngle + offset*i;
                    let intersect = castRay(newAngle, startCellX, startCellY);

                    if(intersect.tileFound){
                        let intersectionX = startCellX + (intersect.dx * intersect.rayLength);
                        let intersectionY = startCellY + (intersect.dy * intersect.rayLength);
                        ctx.save()
                        ctx.fillStyle = "yellow";
                        ctx.beginPath();
                        ctx.arc(Math.round(intersectionX*gridSize), Math.round(intersectionY*gridSize), 4, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.restore();

                        let textureCoordinate;
                        if(intersect.side == "y"){
                            textureCoordinate = Math.floor(32*(intersectionX - Math.floor(intersectionX)));
                        }else{
                            textureCoordinate = Math.floor(32*(intersectionY - Math.floor(intersectionY)));
                        }

                        
                        let gridX = Math.floor(intersectionX);
                        let gridY = Math.floor(intersectionY);
                        if(intersect.side == "y" &&  intersectionY < startCellY && gridY > 0){
                            gridY -= 1;
                        }
                        if(intersect.side == "x" &&  intersectionX < startCellX && gridX > 0){
                            gridX -= 1;
                        }
                        dataSquares[gridX][gridY].seen = true;
                        
                        rayIntersections[i+halfRes] = {
                            distance:intersect.rayLength,
                            side:intersect.side,
                            angle: newAngle,
                            intersects:true,
                            x:intersectionX,
                            y:intersectionY,
                            textureCoordinate:textureCoordinate,
                            texture: dataSquares[gridX][gridY]['texture_'+intersect.side]
                        }
                    }else{
                        rayIntersections[i+halfRes] = {
                            distance:Infinity,
                            side:"",
                            angle:newAngle,
                            intersects:false,
                            x:0,
                            y:0,
                            textureCoordinate:0,
                            texture:""
                        }
                    }
                }
                
            }
            
            function generateMapCode(){
                let binaryString = '';
                let charIndex = 0;
                let thisChar = '';
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        charIndex++;
                        if(gridSquares[i][ii]){
                            thisChar += "1";
                        }else{
                            thisChar += "0";
                        }
                        if(charIndex % 4 == 0){
                            charIndex = 0;
                            
                            binaryString += String.fromCharCode(32 + parseInt(thisChar,2));
                            thisChar = "";
                        }
                        
                        
                    }
                }

                for(var i = 0; i < spriteList.length; i++){
                    if(spriteList[i] instanceof RobotSprite || spriteList[i] instanceof BunnySprite || spriteList[i] instanceof DoorSprite || spriteList[i] instanceof KeySprite || spriteList[i] instanceof TreeSprite){
                        let type;
                        if(spriteList[i] instanceof DoorSprite){
                            if(spriteList[i].direction == 'x'){
                                type = 5 + spriteList[i].type;   
                            }else{
                                type = 8 + spriteList[i].type;
                            }
                        }else if(spriteList[i] instanceof KeySprite){
                            type = 2 + spriteList[i].type;
                        }else if(spriteList[i] instanceof TreeSprite){
                            type = 12;
                        } else if(spriteList[i] instanceof BunnySprite){
                            type = 13;
                        } else if(spriteList[i] instanceof RobotSprite){
                            type = 14;
                        }
                        binaryString += String.fromCodePoint(type + 32);
                        binaryString += String.fromCodePoint(Math.floor(spriteList[i].xPos/gridSize) + 32);
                        binaryString += String.fromCodePoint(Math.floor(spriteList[i].yPos/gridSize) + 32);
                    }
                }

                
                let map_code = document.getElementById("map_code");
                map_code.value = binaryString;
            }

            function mapFromCode(code){
                spriteList = [];
                teleporter = new Teleporter(ctx, textureLoader.imageList['bed'], 256, 256, 0, gridSize, resolution);
                teleporter.active = false;
                spriteList.push(teleporter);
                let binaryString = '';
                let gridCode = code.substr(0,256);
                let spriteCode = code.substr(256);
                for(var c = 0; c < gridCode.length; c++){
                    binaryString += (gridCode.codePointAt(c) - 32).toString(2).padStart(4,"0");
                }
                let cellIndex = 0;
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        
                        if(binaryString.substr(cellIndex,1) == "1"){
                            gridSquares[i][ii] = true;
                        }else{
                            gridSquares[i][ii] = false;
                        }
                        cellIndex++;
                    }
                }
                generateSeenGrid();
                
                for(var i = 0; i < spriteCode.length; i += 3){
                    let type = spriteCode.codePointAt(i) - 32;
                    let gridX = spriteCode.codePointAt(i+1) - 32;
                    let gridY = spriteCode.codePointAt(i+2) - 32;
                    switch(type){
                        case 1: //doorx
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', 1));
                        break;
                        case 2: //doory
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'y', 1));
                        break;
                        case 3: //key
                            spriteList.push(new KeySprite(ctx, textureLoader.imageList['key'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, type - 2));
                        break;
                        case 4:
                            spriteList.push(new KeySprite(ctx, textureLoader.imageList['key_silver'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, type - 2));
                        break;
                        case 5:
                            spriteList.push(new KeySprite(ctx, textureLoader.imageList['key_bronze'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, 0, gridSize, gridSize, type - 2));
                        break;

                        case 6: //doorx 
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', type-5));
                        break;
                        case 7: //doorx
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door_silver'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', type-5));
                        break;
                        case 8: //doorx
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door_bronze'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'x', type-5));
                        break;
                        case 9: //doory
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'y', type-8));
                        break;
                        case 10: //doory
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door_silver'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'y', type-8));
                        break;
                        case 11: //doory
                            spriteList.push(new DoorSprite(ctx, textureLoader.imageList['door-open'], textureLoader.imageList['door_bronze'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize, 'y', type-8));
                        break;
                        case 12: //tree
                            spriteList.push(new TreeSprite(ctx, textureLoader.imageList['tree'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize));
                        break;
                        case 13: //bunny
                            spriteList.push(new BunnySprite(ctx, textureLoader.imageList['bunny'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize));
                        break;
                        case 14: //robo
                            spriteList.push(new RobotSprite(ctx, textureLoader.imageList['robo'], gridX*gridSize + gridSize/2, gridY*gridSize + gridSize/2, gridSize, gridSize));
                        break;
                    }
                }
            }

            load_map_btn.addEventListener("click", function(e){
                e.preventDefault();
                mapFromCode(map_code.value);
                return false;
            });

            function translateKeyControls(key){
                switch(key){
                    case 'ArrowUp':
                        return 'w';
                    break;
                    case 'ArrowLeft':
                        return 'a';
                    break;
                    case 'ArrowRight':
                        return 'd';
                    break;
                    case 'ArrowDown':
                        return 's';
                    break;
                    default:
                        return key;
                }
            }
            
            document.addEventListener("keydown",function(e){
                let key = translateKeyControls(e.key);
                keyInputs[key] = true;
            });

            document.addEventListener("keyup",function(e){
                let key = translateKeyControls(e.key);
                keyInputs[key] = false;
            });

            canvas.addEventListener("mousemove",function(e){
                mouseInput.x = e.offsetX;
                mouseInput.y = e.offsetY;
            });

            canvas.addEventListener("touchmove",function(e){
                mouseInput.y = e.changedTouches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput.x = e.changedTouches[0].clientX - canvas.offsetLeft;
            });

            canvas.addEventListener("mousedown", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = true;
                }else if(e.button == 2){
                    mouseInput.altClick = true;
                }else if(e.button = 1){
                    mouseInput.middleClick = true;
                }
                return false;
            });

            canvas.addEventListener("touchstart", function(e){
                e.preventDefault();
                mouseInput.y = e.touches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput.x = e.touches[0].clientX - canvas.offsetLeft;
                mouseInput.click = true;
                return false;
            });

            canvas.addEventListener("touchend", function(e){
                e.preventDefault();
                mouseInput.click = false;
                return false;
            });

            map_edit_btn.addEventListener("click", function(e){
                e.preventDefault();
                map_edit_container.style.display = "block";
                map_edit_btn.style.display = "none";
                canvas.style.transform = "";
                canvas.style.opacity = "1";
                MAP_EDIT_MODE = true;
                return false;
            })

            

            canvas.addEventListener("mouseup", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = false;
                }else if(e.button == 2){
                    mouseInput.altClick = false;
                }else if(e.button == 1){
                    mouseInput.middleClick = false;
                }
                //reset on mouseup
                lastMouseAction = {
                    button:-1,
                    gridX:0,
                    gridY:0
                };
                return false;
            });

            canvasCamera.addEventListener("mousemove",function(e){
                mouseInput_game.x = e.offsetX;
                mouseInput_game.y = e.offsetY;
            });

            canvasCamera.addEventListener("touchmove",function(e){
                mouseInput_game.y = e.changedTouches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput_game.x = e.changedTouches[0].clientX - canvas.offsetLeft;
            });

            canvasCamera.addEventListener("mousedown", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput_game.click = true;
                }else if(e.button == 2){
                    mouseInput_game.altClick = true;
                }else if(e.button = 1){
                    mouseInput_game.middleClick = true;
                }
                return false;
            });

            canvasCamera.addEventListener("touchstart", function(e){
                e.preventDefault();
                mouseInput_game.y = e.touches[0].clientY - canvas.offsetTop + document.scrollingElement.scrollTop;
                mouseInput_game.x = e.touches[0].clientX - canvas.offsetLeft;
                mouseInput_game.click = true;
                return false;
            });

            canvasCamera.addEventListener("touchend", function(e){
                e.preventDefault();
                mouseInput_game.click = false;
                return false;
            });

            canvas.addEventListener("contextmenu",function(e){
                e.preventDefault();
                e.stopPropagation();
                return false;
            });

            canvasCamera.addEventListener("contextmenu",function(e){
                e.preventDefault();
                e.stopPropagation();
                return false;
            });

            canvasCamera.addEventListener("mouseup", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput_game.click = false;
                }else if(e.button == 2){
                    mouseInput_game.altClick = false;
                }else if(e.button == 1){
                    mouseInput_game.middleClick = false;
                }
                return false;
            });

            let keys = document.getElementsByClassName('key');
            for(var i = 0; i < keys.length; i++){
                keys[i].addEventListener('touchstart', function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    let key = this.getAttribute("data-key");
                    keyInputs[key] = true;
                    return false;
                });
                keys[i].addEventListener('touchend', function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    let key = this.getAttribute("data-key");
                    keyInputs[key] = false;
                    return false;
                });
                keys[i].addEventListener('contextmenu', function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    return false;

                })
            }

            function createStrawb(x,y){
                strawb  = new StrawberrySprite(ctx, textureLoader.imageList['strawb'], x, y, 0, gridSize, resolution);
                return strawb;
            }
            var teleporter;
            function generateWorld(){
                sceneScore = 0;
                keyCount = {};

                let flowerCount = Math.round(Math.random()*20) + 10;
                let strawbSpawnCount = Math.round(Math.random()*15) + 5;
                sceneGoal = strawbSpawnCount;
                for(var i = 0; i < flowerCount; i++){
                    let thisSpriteX = (Math.round(Math.random() * (ctx.canvas.width - 2*gridSize))) + gridSize;
                    let thisSpriteY = (Math.round(Math.random() * (ctx.canvas.height - 2*gridSize))) + gridSize;
                    if(!gridSquares[Math.floor(thisSpriteX/gridSize)][Math.floor(thisSpriteY/gridSize)]){
                        spriteList.push(new Grass(ctx, textureLoader.imageList['flower'], thisSpriteX, thisSpriteY, 0, gridSize, resolution));
                    }else{
                        i--; //try again
                        console.log("try again")
                    }
                }

                for(var i = 0; i < strawbSpawnCount; i++){
                    let thisSpriteX = (Math.round(Math.random() * (ctx.canvas.width - 2*gridSize))) + gridSize;
                    let thisSpriteY = (Math.round(Math.random() * (ctx.canvas.height - 2*gridSize))) + gridSize;
                    if(!gridSquares[Math.floor(thisSpriteX/gridSize)][Math.floor(thisSpriteY/gridSize)]){
                        spriteList.push(createStrawb(thisSpriteX,thisSpriteY));
                    }else{
                        i--; //try again
                        console.log("try again")
                    }
                    
                }

            }

            let select = document.getElementById("map_select")
            for(var i = 0; i < mapLevels.length; i++){
                let thisOption = document.createElement("option");
                thisOption.text = 'Level ' + (i + 1);
                thisOption.value = i;
                select.appendChild(thisOption);
            }
            select.addEventListener("change", function(){
                userInterface.sceneChange(0, player, this.value);
            })
            

            function isTouchDevice() {
            return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
            }

            if(!isTouchDevice()){
                touch_input_container.style.display = "none";
            }else{
                canvas.style.display = "none";
                map_edit_btn.style.display = "none";
            }
            soundLoader.load("sound/defeat.mp3", "defeat");
            soundLoader.load("sound/alarm.mp3", "alarm");
            soundLoader.load("sound/bleat_hurt.mp3", "bleat_hurt");
            soundLoader.load("sound/hit.mp3", "hit");
            soundLoader.load("sound/shoot.mp3", "shoot");
            soundLoader.load("sound/unlock.mp3", "unlock");
            
            soundLoader.load("sound/key.mp3", "key");
            
            soundLoader.load("sound/bush.mp3", "bush");
            
            soundLoader.load("sound/ambiance.mp3", "ambiance");
            
            soundLoader.soundList['ambiance'].loop = true;
            soundLoader.load("sound/bleat.mp3", "bleat");
            soundLoader.load("sound/step1.mp3", "step1");
            
            soundLoader.load("sound/step2.mp3", "step2");
            
            function defaultSoundLevels(){
                for(const sound in soundLoader.soundList){
                    soundLoader.soundList[sound].volume = 1;
                }
                soundLoader.soundList['unlock'].volume = 0.4;
                soundLoader.soundList['key'].volume = 0.4;
                soundLoader.soundList['bush'].volume = 0.4;
                soundLoader.soundList['ambiance'].volume = 0.3;
                soundLoader.soundList['step1'].volume = 0.3;
                soundLoader.soundList['step2'].volume = 0.3;
            }

            soundLoader.onload(function(){
                defaultSoundLevels();
                textureLoader.load("img/key.png", 'key');
                textureLoader.load("img/key_bronze.png", 'key_bronze');
                textureLoader.load("img/key_silver.png", 'key_silver');
                textureLoader.load("img/door.png", 'door');
                textureLoader.load("img/door_silver.png", 'door_silver');
                textureLoader.load("img/door_bronze.png", 'door_bronze');
                textureLoader.load("img/door-open.png", 'door-open');
                textureLoader.load("img/bed.png", 'bed');
                textureLoader.load("img/bullet.png", 'bullet');
                textureLoader.load("img/wall1.png", 'wall1');
                textureLoader.load("img/wall2.png", 'wall2');
                textureLoader.load("img/wall3.png", 'wall3');
                textureLoader.load("img/wall4.png", 'wall4');
                textureLoader.load("img/shoot_1.png", 'shoot_1');
                textureLoader.load("img/shoot_2.png", 'shoot_2');
                textureLoader.load("img/shoot_3.png", 'shoot_3');
                textureLoader.load("img/hoof.png", 'hoof');
                textureLoader.load("img/hoof_blue.png", 'hoof_blue');
                textureLoader.load("img/strawb.png", 'strawb');
                textureLoader.load("img/deer-face.png", 'face');
                textureLoader.load("img/deer-face-blink.png", 'face-blink');
                textureLoader.load("img/deer-face-closed.png", 'face-close');
                textureLoader.load("img/deer-blush.png", 'face-blush');
                textureLoader.load("img/flower.png", 'flower');
                textureLoader.load("img/splash.png", 'splash');
                textureLoader.load("img/tree.png", 'tree');
                textureLoader.load("img/bunny.png", 'bunny');
                textureLoader.load("img/bunny-back.png", 'bunny_back');
                textureLoader.load("img/bullet_glow.png", 'bullet_glow');
                textureLoader.load("img/robo.png", 'robo');
                textureLoader.load("img/robo_back.png", 'robo_back');
                textureLoader.load("img/robo_destroyed.png", 'robo_destroyed');
                textureLoader.load("img/robo_back_destroyed.png", 'robo_back_destroyed');
                textureLoader.load("img/hit.png", 'hit');
                textureLoader.load("img/net_bullet.png", 'net');
                textureLoader.load("img/defeat_splash.png", 'defeat_splash');
                textureLoader.onload(function(){
                    console.log("loaded");
                    let faceImg = textureLoader.imageList['face'];
                    let faceBlink = textureLoader.imageList['face-blink'];
                    let faceClose = textureLoader.imageList['face-close'];
                    let faceBlush = textureLoader.imageList['face-blush'];
                    bulletImageRotation = precalculateImageRotation(textureLoader.imageList['bullet'], [textureLoader.imageList['bullet_glow']], 32, 64, 64);
                    netImageRotation = precalculateImageRotation(textureLoader.imageList['net'], [], 32, 128, 128);
                    userInterface = new UserInterface(ctxCamera,  faceImg, faceBlink, faceClose, faceBlush);
                    splashScreen = new Splash(ctxCamera, textureLoader.imageList['splash']);
                    
                    mapFromCode(level_1);
                    generateWorld();
                    generateMapCode();
                    play(0);
                });
            });

        </script>
    </body>
    <footer>
        
    </footer>
</html>