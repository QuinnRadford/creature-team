<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=512, user-scalable=0, viewport-fit=contain"/>
    </head>
    <body>
        <style>
            .controls-container{
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                margin:auto;
                max-width: 400px;
                gap:16px;
                margin-top:35px;
            }
            .controls-container>div{
                flex-basis: calc(33.33% - 16px);
                height:100px;
                
                align-content: center;
                text-align: center;
                border-radius: 8px;
                
            }
            .controls-container>.key{
                outline: 2px solid black;
                background: grey;
                user-select: none;
                cursor: pointer;
            }
            body{
                min-width: 512px;
            }
        </style>
        <canvas id="game" width="512" height="512">

        </canvas>
        <canvas id="camera" width="512" height="512">

        </canvas>
        <div class="controls-container">
            <div></div><div class="key" data-key="w">W</div><div></div>
            <div class="key" data-key="a">A</div>
            <div class="key" data-key="s">S</div>
            <div class="key" data-key="d">D</div>
        </div>
        <script>
            const canvasCamera = document.getElementById('camera');
            /** @type {CanvasRenderingContext2D} */
            const ctxCamera = canvasCamera.getContext('2d');

            const canvas = document.getElementById('game');
            /** @type {CanvasRenderingContext2D} */
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "black";
            ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
            var gridSize = 16;
            var resolution = 128;
            var halfRes = 64;
            var keyInputs = {
                w:false,
                s:false,
                a:false,
                d:false,
            };
            var strawb;
            var hoof;
            var player;
            var rayIntersections;
            var spriteList = [];
            var spriteRenders = [];

            var strawbCount = 0;

            var interface;

            var mouseInput = {
                x:0,
                y:0,
                click:false,
                altClick:false
            }

            class ImageLoader{
                promiseList = [];
                imageList = {};
                constructor(){

                }

                load(url, name){
                    let imageLoader = this;
                    this.promiseList.push(new Promise(function(resolve,reject){
                        imageLoader.imageList[name] = new Image();
                        imageLoader.imageList[name].onload = function(){return resolve();}
                        imageLoader.imageList[name].onerror = function(){return reject();}
                        imageLoader.imageList[name].src = url;
                    }));
                }

                onload(callback){
                    Promise.all(this.promiseList).then(callback);
                }
            }

            var textureList = new ImageLoader();

            //init grid
            var gridSquares = [];
            for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                gridSquares[i] = [];
                for(var ii = 0; ii < ctx.canvas.height/gridSize; ii++){
                    if(ii == 0 || ii == Math.round(ctx.canvas.height/gridSize - 1) || i == 0 || i == Math.round(ctx.canvas.width/gridSize - 1)){
                        gridSquares[i][ii] = true;
                    }else{
                        gridSquares[i][ii] = false;
                    }
                    
                }
            }

            function drawSquares(ctx, gridSize){
                ctx.save();
                ctx.fillStyle = 'blue';
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        if(gridSquares[i][ii]){
                            ctx.fillRect(i*gridSize,ii*gridSize,gridSize,gridSize);
                        }
                    }
                }
                ctx.restore();
            }


            

            function generateGrid(gridSize){
                ctx.fillStyle = "black";
                ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                    let lineY = i*gridSize
                    ctx.beginPath();
                    ctx.moveTo(0,lineY);
                    ctx.lineTo(ctx.canvas.width,lineY);
                    ctx.stroke();
                }
                for(var i = 0; i < ctx.canvas.height/gridSize; i++){
                    let lineX = i*gridSize
                    ctx.beginPath();
                    ctx.moveTo(lineX,0)
                    ctx.lineTo(lineX, ctx.canvas.height);
                    ctx.stroke();
                }
            }

            class Hoof{
                isWalking = false;
                isAnimating = false;
                /** @type {CanvasRenderingContext2D} */
                ctx;
                screenX = 150;
                screenY = 160;
                initialY;
                animateSpeed = 0.15;
                topLimit = 20;
                bottomLimit = -20;
                animateMode = 1;
                width = 69;
                height = 240;
                constructor(ctx){
                    this.ctx = ctx;
                    this.screenY = ctx.canvas.height - this.screenY;
                    this.initialY = this.screenY;
                    this.screenX = ctx.canvas.height - this.screenX;
                    this.topLimit += this.screenY;
                    this.bottomLimit += this.screenY;

                }
                animate(deltaT){
                    if(keyInputs.s || keyInputs.w){
                        this.isWalking = true;
                        this.isAnimating = true;
                    }else{
                        this.isWalking = false;
                    }

                    if(this.isAnimating){
                        if(this.animateMode == 1){
                            this.screenY += (this.animateSpeed*deltaT)
                        }else{
                            this.screenY -= (this.animateSpeed*deltaT)
                        }
                        
                        
                        if(this.screenY <= this.bottomLimit){
                            this.animateMode = 1;
                            this.screenY = this.bottomLimit;
                        }else if(this.screenY >= this.topLimit){
                            this.animateMode = 0;
                            this.screenY = this.topLimit;
                        }

                        if((this.screenY <= this.bottomLimit || this.screenY >= this.topLimit || Math.abs(this.screenY - this.initialY) <= 2) && !this.isWalking){
                            this.isAnimating = false;
                        }

                    }
                    
                }

                draw(){
                    this.ctx.drawImage(textureList.imageList['hoof'], Math.round(this.screenX), Math.round(this.screenY), this.width, this.height);
                }

            }

            class Sprite{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                xPos;
                yPos;
                zPos;
                directionX;
                directionY;
                image;
                width;
                distance;
                active = true;

                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    this.ctx = ctx;

                    this.image = image;
                    this.xPos = xPos;
                    this.yPos = yPos;
                    this.zPos = zPos;
                    this.width = width/gridSize;
                    this.height = height;
                }
                
                draw(player){
                    if(!this.active) return true;
                    this.ctx.save();
                    this.ctx.fillStyle = "orange";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.restore();

                    /* this.ctx.save();
                    let yRelative = (player.yPos - this.yPos)/gridSize;
                    let xRelative = (player.xPos - this.xPos)/gridSize;


                    let gridAngle = Math.atan2(yRelative, xRelative);

                    let playerAngle = Math.atan2(player.directionY, player.directionX);

                    
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    let edgeDistance = Math.sqrt(Math.pow(playerDistance,2) + Math.pow(this.width/2,2));
                    
                    let edgeAngle = Math.atan2(playerDistance, this.width/2);


                    let lineAngle = (gridAngle - Math.PI/2);
                    let linedx = Math.cos(lineAngle);
                    let linedy = Math.sin(lineAngle);
                    
                    let edge1x = this.xPos/gridSize + (linedx*this.width/2);
                    let edge1y = this.yPos/gridSize + (linedy*this.width/2);

                    let edge2x = this.xPos/gridSize - (linedx*this.width/2);
                    let edge2y = this.yPos/gridSize - (linedy*this.width/2);

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "orange";
                    this.ctx.moveTo(edge1x*gridSize, edge1y*gridSize);
                    this.ctx.lineTo(edge2x * gridSize, edge2y * gridSize);
                    this.ctx.stroke();

                    this.ctx.fillStyle = "green";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(edge1x*gridSize), Math.round(edge1y*gridSize), 2, 0, 2*Math.PI);
                    this.ctx.fill();
                    
                    let yRelative2 = (player.yPos/gridSize) - edge1y;
                    let xRelative2 = (player.xPos/gridSize) - edge1x;
                    let edgeAngle1 = Math.atan2(yRelative2, xRelative2);

                    let yRelative3 = (player.yPos/gridSize) - edge2y;
                    let xRelative3 = (player.xPos/gridSize) - edge2x;
                    let edgeAngle2 = Math.atan2(yRelative3, xRelative3);

                    let e1dX = Math.cos(edgeAngle1);
                    let e1dY = Math.sin(edgeAngle1);
                    let e2dX = Math.cos(edgeAngle2);
                    let e2dY = Math.sin(edgeAngle2);

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "green";
                    this.ctx.moveTo(Math.round(edge1x*gridSize), Math.round(edge1y*gridSize));
                    this.ctx.lineTo(Math.round(edge1x*gridSize + (edgeDistance*e1dX*gridSize)), Math.round(edge1y*gridSize + (edgeDistance*e1dY*gridSize)));
                    this.ctx.stroke();

                    this.ctx.strokeStyle = "yellow";
                    this.ctx.moveTo(Math.round(edge2x*gridSize), Math.round(edge2y*gridSize));
                    this.ctx.lineTo(Math.round(edge2x*gridSize + (edgeDistance*e2dX*gridSize)), Math.round(edge2y*gridSize + (edgeDistance*e2dY*gridSize)));
                    this.ctx.stroke();

                    this.ctx.restore(); */
                }

                isVisible(player, rayIntersections){
                    if(!this.active) return true;
                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;


                    let gridAngle = Math.atan2(yRelative, xRelative);

                    let playerAngle = Math.atan2(player.directionY, player.directionX);

                    
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    let edgeDistance = Math.sqrt(Math.pow(playerDistance,2) + Math.pow(this.width/2,2));
                    
                    let edgeAngle = Math.atan2(playerDistance, this.width/2);


                    let lineAngle = (gridAngle - Math.PI/2);
                    let linedx = Math.cos(lineAngle);
                    let linedy = Math.sin(lineAngle);
                    
                    let edge1x = this.xPos/gridSize + (linedx*this.width/2);
                    let edge1y = this.yPos/gridSize + (linedy*this.width/2);

                    let edge2x = this.xPos/gridSize - (linedx*this.width/2);
                    let edge2y = this.yPos/gridSize - (linedy*this.width/2);

                    let yRelative2 = (player.yPos/gridSize) - edge1y;
                    let xRelative2 = (player.xPos/gridSize) - edge1x;
                    let edgeAngle1 = Math.atan2(yRelative2, xRelative2);

                    let yRelative3 = (player.yPos/gridSize) - edge2y;
                    let xRelative3 = (player.xPos/gridSize) - edge2x;
                    let edgeAngle2 = Math.atan2(yRelative3, xRelative3);
                    
                    
                    
                    edgeAngle1 = (edgeAngle1 - Math.PI);
                    edgeAngle2 = (edgeAngle2 - Math.PI);

                    
                    let ay = Math.sin(edgeAngle1);
                    let ax = Math.cos(edgeAngle1);

                    let cy = Math.sin(edgeAngle2);
                    let cx = Math.cos(edgeAngle2);
                    let AxC = ay*cx - ax*cy;
                    let CxA = cy*ax - cx*ay;

                    



                    //these have bad names
                    let a1y = Math.sin(edgeAngle1);
                    let a1x = Math.cos(edgeAngle1);

                    let c1y = Math.sin(edgeAngle2);
                    let c1x = Math.cos(edgeAngle2);
                    let AxC1 = a1y*cx - a1x*c1y;
                    let CxA1 = c1y*ax - c1x*a1y;
                    
                    
                    let b1y = ay;
                    let b1x = ax;
                    let AxB1 = a1y*b1x - a1x*b1y;
                    let CxB1 = c1y*b1x - c1x*b1y;

                    let b2y = cy;
                    let b2x = cx;
                    let AxB2 = a1y*b2x - a1x*b2y;
                    let CxB2 = c1y*b2x - c1x*b2y;
                    

                    //test if the edges of the sprite are within the view cone for performance
                    if(!((AxB1 * AxC1 >= 0 && CxB1 * CxA1 >= 0) || AxB2 * AxC1 >= 0 && CxB2 * CxA1 >= 0)){
                        return false;
                    }
                    
                    for(const pixel in rayIntersections){
                        
                        if(rayIntersections[pixel].distance <= playerDistance){
                            continue;
                        }else{
                            //ray touches sprite

                            let by = Math.sin(rayIntersections[pixel].angle);
                            let bx = Math.cos(rayIntersections[pixel].angle);

                            let AxB = ay*bx - ax*by;
                            let CxB = cy*bx - cx*by;
                            
                            //vector b lies within a and b
                            if(AxB * AxC >= 0 && CxB * CxA >= 0){
                                let coord = edgeAngle1 - edgeAngle2;
                                let angle = edgeAngle1 - rayIntersections[pixel].angle;
                                let percent = angle/coord;

                                let diffAngle = rayIntersections[pixel].angle - gridAngle
                                
                                let segment = Math.tan(diffAngle)*playerDistance;

                                let linesegment = (segment + this.width/2)/this.width

                                spriteRenders.push(
                                    {
                                        pixel:pixel,
                                        distance: playerDistance,
                                        texture: this.image,
                                        textureCoordinate : Math.abs(Math.floor(this.image.width * linesegment)),
                                    }
                                )
                            }
                        }
                    }

                }
            }

            class UserInterface{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                faceImg;
                imgLayerBlink;
                imgLayerClose;
                imgLayerBlush;

                netxBlink = 0;
                nextClose = 0;
                blinking = false;
                closed = false;
                faceSize = 100;
                borderWidth = 4;
                insetWidth = 2;
                oldScore = 0;
                blush = false;
                blushStart = 0;

                constructor(ctx, faceImg, blink, closed, blush){
                    this.ctx = ctx;
                    this.faceImg = faceImg;
                    this.imgLayerBlink = blink;
                    this.imgLayerClose = closed;
                    this.imgLayerBlush = blush;
                }

                update(){
                    let now = performance.now();
                    if(now > this.netxBlink){
                        if(this.netxBlink != 0){
                             this.blinking = true;
                        }
                        if(now - this.netxBlink > 500){
                            this.blinking = false;
                            this.netxBlink = now + ((Math.random() * 5000) + 2500);
                            
                        }
                    }

                    if(now > this.nextClose){
                        this.closed = true;
                        if(now - this.nextClose > 4000){
                            if(this.nextClose != 0) this.closed = false;
                            this.nextClose = now + ((Math.random() * 10000) + 5000);
                        }
                    }

                    if(this.blush && now - this.blushStart > 1000 && this.blushStart != 0){
                        this.blush = false;
                        this.blinking = false;
                        this.nextClose = now + ((Math.random() * 5000) + 5000);
                        this.netxBlink = now + ((Math.random() * 5000) + 2500);
                    }else if(now - this.blushStart <= 1000 && this.blushStart != 0){
                        this.blinking = true;
                        this.closed = false;
                    }

                    if(this.oldScore < strawbCount){
                        this.oldScore = strawbCount;
                        this.setBlush();
                    }
                }

                setBlinking(){
                    this.blinking = true;
                    this.netxtBlink = performance.now();
                }

                setClosed(){
                    this.closed = true;
                    this.nextClose = performance.now();
                }

                setOpen(){
                    this.closed = false;
                    this.nextClose = performance.now() + ((Math.random() * 10000) + 5000);
                }

                setBlush(){
                    this.blush = true;
                    this.blinking = true;
                    this.blushStart = performance.now();
                }

                _drawFaceFrame(){
                    //face frame
                    this.ctx.save();
                    this._drawInsetBox(0,0,this.faceSize, this.faceSize)
                    this.ctx.drawImage(this.faceImg, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))

                    if(this.blinking){
                        this.ctx.drawImage(this.imgLayerBlink, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }
                    if(this.closed){
                        this.ctx.drawImage(this.imgLayerClose, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }

                    if(this.blush){
                        this.ctx.drawImage(this.imgLayerBlush, this.borderWidth + this.insetWidth, this.ctx.canvas.height - this.faceSize + this.borderWidth + this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, this.faceSize - 2*(this.insetWidth + this.borderWidth))
                    }


                    this.ctx.restore();
                }

                //x y relative bottom left
                _drawInsetBox(x,y,width, height){
                    this.ctx.fillStyle = "teal";
                    this.ctx.fillRect(x, y+this.ctx.canvas.height - height, width, height);
                    
                    this.ctx.fillStyle = "grey"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);

                    this.ctx.fillStyle = "white"
                    this.ctx.fillRect(x+this.borderWidth, y+this.ctx.canvas.height - this.borderWidth - this.insetWidth, width - this.borderWidth*2 - this.insetWidth, this.insetWidth);
                    this.ctx.fillRect(x+width - 2*this.borderWidth, y+this.ctx.canvas.height - height + this.borderWidth, this.insetWidth, height - this.borderWidth*2);
                    
                    this.ctx.fillStyle = "darkSlateGrey";
                    this.ctx.fillRect(x+this.borderWidth + this.insetWidth, y+this.ctx.canvas.height - height + this.borderWidth + this.insetWidth, width - 2*(this.insetWidth + this.borderWidth) - this.insetWidth, height - 2*(this.insetWidth + this.borderWidth));
                    
                }

                _drawScore(){
                    let scoreBox = 50;
                    this.ctx.save();
                    this._drawInsetBox(this.faceSize, 0, scoreBox, scoreBox)
                    this.ctx.font = "bold 28px sans-serif";
                    this.ctx.textAlign = "center";
                    this.ctx.fillStyle = "white";
                    this.ctx.fillText(strawbCount, this.faceSize + this.borderWidth + this.insetWidth + (scoreBox - 2*(this.borderWidth + this.insetWidth))/2, this.ctx.canvas.height - (2*this.borderWidth + this.insetWidth) - 4);
                    this.ctx.restore();
                }

                draw(){
                    this._drawFaceFrame();
                    this._drawScore();
                }
            }

            class StrawberrySprite extends Sprite{
                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    super(ctx, image, xPos, yPos, zPos, width, height);
                }

                isVisible(player, rayIntersections){
                    super.isVisible(player, rayIntersections);
                    
                    if(this.active){
                        let yRelative = ( this.yPos - player.yPos)/gridSize;
                        let xRelative = ( this.xPos - player.xPos)/gridSize;
                        let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                        if(playerDistance < 0.3){
                            strawbCount += 1;
                            this.active = false;
                        }
                    }
                }

                draw(player){
                    if(!this.active) return true;
                    this.ctx.save();
                    this.ctx.fillStyle = "red";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.restore();
                }
            }
            class Player{
                /** @type {CanvasRenderingContext2D} */
                ctx;
                xPos;
                yPos;
                speed = 80;
                rSpeed = 200;
                directionX = 0;
                directionY = 0;
                constructor(ctx, xPos, yPos){
                    this.ctx = ctx;
                    this.xPos = xPos;
                    this.yPos = yPos;
                }
                draw(){
                    this.ctx.save()
                    this.ctx.fillStyle = "green";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "yellow";
                    this.ctx.lineWidth = 4;
                    this.ctx.moveTo(this.xPos, this.yPos);
                    this.ctx.lineTo(this.xPos + this.directionX*10, this.yPos + this.directionY*10);
                    this.ctx.stroke();
                    this.ctx.restore();
                }
                animate(deltaT){

                    let dy = 0;
                    let dx = 0;
                    if(keyInputs.w){
                        dy -= this.speed * deltaT/1000;
                    }
                    if(keyInputs.s){
                        dy += this.speed * deltaT/1000;
                    }

                    
                    if(keyInputs.a){
                        dx -= this.rSpeed * deltaT/1000;
                    }
                    if(keyInputs.d){
                        dx += this.rSpeed * deltaT/1000;
                    }

                    if(dx != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        let newAngle = viewAngle + ( dx * 0.0174533);
                        this.directionY = Math.sin(newAngle);
                        this.directionX = Math.cos(newAngle);
                    }

                    if(dy != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        let nextY = this.yPos - Math.sin(viewAngle)*dy;
                        let nextX = this.xPos - Math.cos(viewAngle)*dy;

                        let nextGridY = Math.floor(nextY/gridSize);
                        let nextGridX = Math.floor(nextX/gridSize);

                        if(gridSquares[nextGridX] && !gridSquares[nextGridX][nextGridY]){
                            this.yPos = nextY;
                            this.xPos = nextX;
                        }

                        this.yPos = Math.max(this.yPos, 0);
                        this.yPos = Math.min(this.yPos, ctx.canvas.height);

                        this.xPos = Math.max(this.xPos, 0);
                        this.xPos = Math.min(this.xPos, ctx.canvas.width);
                    }
                }
            }

            hoof = new Hoof(ctxCamera);

            player = new Player(ctx, 256, 256);
            rayIntersections = {};

            function drawMouse(ctx){
                ctx.save()
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(Math.round(mouseInput.x), Math.round(mouseInput.y), 4, 0, 2*Math.PI);
                ctx.fill();
                ctx.restore();
            }

            function paintSquares(mouseInput, gridSize){
                if(mouseInput.click || mouseInput.altClick){
                    let gridX = Math.floor(mouseInput.x/gridSize);
                    let gridY = Math.floor(mouseInput.y/gridSize);
                    if(gridX < gridSquares.length){
                        if(gridY < gridSquares[gridX].length){
                            if(mouseInput.click){
                                gridSquares[gridX][gridY] = true;
                            }else if(mouseInput.altClick){
                                gridSquares[gridX][gridY] = false;
                            }
                        }
                    }
                }
            }

            function compareDistance(a,b){
                if ( a.distance > b.distance ){
                    return -1;
                }
                if ( a.distance < b.distance ){
                    return 1;
                }
                return 0;
            }

            function drawCamera(ctxCamera, rayIntersections){
                ctxCamera.save();
                let skygrad = ctxCamera.createLinearGradient(0, ctxCamera.canvas.height/4, 0, ctxCamera.canvas.height/2);
                skygrad.addColorStop(0, "skyblue");
                skygrad.addColorStop(1, "white");

                ctxCamera.fillStyle = "skyblue";
                ctxCamera.fillRect(0,0,ctxCamera.canvas.width,ctxCamera.canvas.height/2);

                ctxCamera.fillStyle = skygrad;
                ctxCamera.fillRect(0,ctxCamera.canvas.height/4,ctxCamera.canvas.width,ctxCamera.canvas.height/4);

                let groundGrad = ctxCamera.createLinearGradient(0, ctxCamera.canvas.height/2, 0, ctxCamera.canvas.height*0.75);
                groundGrad.addColorStop(0, "#628251");
                groundGrad.addColorStop(1, "#7ca666");

                ctxCamera.fillStyle = "#7ca666";
                ctxCamera.fillRect(0,ctxCamera.canvas.height/2,ctxCamera.canvas.width,ctxCamera.canvas.height/2);

                ctxCamera.fillStyle = groundGrad;
                ctxCamera.fillRect(0,ctxCamera.canvas.height/2,ctxCamera.canvas.width,ctxCamera.canvas.height/4);
                //draw walls
                for(var i = 0; i < resolution; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(rayIntersections[i] && rayIntersections[i].intersects){
                        let height =  256 * (1/rayIntersections[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;
                        ctxCamera.drawImage(textureList.imageList[rayIntersections[i].texture], rayIntersections[i].textureCoordinate, 0, 1, textureList.imageList[rayIntersections[i].texture].height, i*width, yOffset, width, height)
                    }
                }

                spriteRenders.sort(compareDistance);

                for(var i = 0; i < spriteRenders.length; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(spriteRenders[i]){
                        let height =  256 * (1/spriteRenders[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;

                        ctxCamera.drawImage(spriteRenders[i].texture, spriteRenders[i].textureCoordinate, 0, 1, spriteRenders[i].texture.height, spriteRenders[i].pixel*width, yOffset, width, height)
                        
                    }
                }
                

                ctxCamera.restore();
            }


            //main update loop
            function play(deltaT){
                var frameStart = performance.now();
                spriteRenders = [];
                generateGrid(gridSize);
                paintSquares(mouseInput, gridSize);
                drawSquares(ctx, gridSize);
                drawMouse(ctx);
                player.animate(deltaT);
                player.draw();
                rayCastView(ctx, player);
                for(var i = 0; i < spriteList.length; i++){
                    spriteList[i].draw(player);
                    spriteList[i].isVisible(player, rayIntersections);
                }
                drawCamera(ctxCamera, rayIntersections);
                hoof.animate(deltaT);
                hoof.draw();

                interface.update();
                interface.draw();
                

                window.requestAnimationFrame(function(){
                    play(performance.now() - frameStart);
                });
            }


            //check for intersections with walls
            //start and end in grid space
            function castRay(viewAngle, startCellX, startCellY){
                let dx = Math.cos(viewAngle);
                let dy = Math.sin(viewAngle);

                let xRay = 0;
                let yRay = 0;

                //scaling factor step size
                let sx =  Math.sqrt(1 + Math.pow(dy/dx,2));
                let sy = Math.sqrt(1 + Math.pow(dx/dy,2));

                let tileCheckX = Math.floor(startCellX);
                let tileCheckY = Math.floor(startCellY);

                //step directions
                let xStep;
                if(dx < 0){
                    xStep = -1;
                    xRay = (startCellX - tileCheckX) * sx;
                }else{
                    xStep = 1;
                    xRay = (tileCheckX + 1 - startCellX) * sx;
                }
                
                let yStep;
                if(dy < 0){
                    yStep = -1;
                    yRay = (startCellY - tileCheckY) * sy;
                }else{
                    yStep = 1;
                    yRay = (tileCheckY + 1 - startCellY) * sy;
                }

                let tileFound = false;
                let rayLength = 0;
                let side;
                while(!tileFound && rayLength < 512){
                    if(xRay < yRay){
                        tileCheckX += xStep;
                        rayLength = xRay;
                        xRay += sx;
                        side = "x";
                    }else{
                        tileCheckY += yStep;
                        rayLength = yRay;
                        yRay += sy;
                        side = "y";
                    }

                    if(tileCheckX >= 0 &&  tileCheckY >= 0 && tileCheckX < gridSquares.length && tileCheckY < gridSquares[tileCheckX].length){
                        if(gridSquares[tileCheckX][tileCheckY]){
                            tileFound = true;
                        }
                    }
                }

                return {
                    tileFound:tileFound,
                    dx:dx,
                    dy:dy,
                    rayLength:rayLength,
                    side:side
                }
            }

            function rayCastView(ctx, player){

                //start and end points in grid space
                let startCellX = player.xPos/gridSize;
                let startCellY = player.yPos/gridSize;

                //unit vector
                let dx = player.directionX;
                let dy = player.directionY;
                let viewAngle = Math.atan2(dy, dx);
                
                for(var i = -1*halfRes; i <= halfRes; i++){
                    let offset = (Math.PI/2)/resolution;
                    let newAngle = viewAngle + offset*i;
                    let intersect = castRay(newAngle, startCellX, startCellY);

                    if(intersect.tileFound){
                        let intersectionX = startCellX + (intersect.dx * intersect.rayLength);
                        let intersectionY = startCellY + (intersect.dy * intersect.rayLength);
                        ctx.save()
                        ctx.fillStyle = "yellow";
                        ctx.beginPath();
                        ctx.arc(Math.round(intersectionX*gridSize), Math.round(intersectionY*gridSize), 4, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.restore();

                        let textureCoordinate;
                        if(intersect.side == "y"){
                            textureCoordinate = Math.floor(32*(intersectionX - Math.floor(intersectionX)));
                        }else{
                            textureCoordinate = Math.floor(32*(intersectionY - Math.floor(intersectionY)));
                        }
                        
                        rayIntersections[i+halfRes] = {
                            distance:intersect.rayLength,
                            side:intersect.side,
                            angle: newAngle,
                            intersects:true,
                            x:intersectionX,
                            y:intersectionY,
                            textureCoordinate:textureCoordinate,
                            texture:"wall"
                        }
                    }else{
                        rayIntersections[i+halfRes] = {
                            distance:Infinity,
                            side:"",
                            angle:newAngle,
                            intersects:false,
                            x:0,
                            y:0,
                            textureCoordinate:0,
                            texture:""
                        }
                    }
                }
                
            }

            
            document.addEventListener("keydown",function(e){
                keyInputs[e.key] = true;
            });

            document.addEventListener("keyup",function(e){
                keyInputs[e.key] = false;
            });

            canvas.addEventListener("mousemove",function(e){
                mouseInput.x = e.offsetX;
                mouseInput.y = e.offsetY;
            });

            canvas.addEventListener("touchmove",function(e){
                mouseInput.y = e.changedTouches[0].clientY - canvas.offsetTop;
                mouseInput.x = e.changedTouches[0].clientX - canvas.offsetLeft;
            });

            canvas.addEventListener("mousedown", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = true;
                }else if(e.button == 2){
                    mouseInput.altClick = true;
                }
                return false;
            });

            canvas.addEventListener("touchstart", function(e){
                e.preventDefault();
                mouseInput.y = e.touches[0].clientY - canvas.offsetTop;
                mouseInput.x = e.touches[0].clientX - canvas.offsetLeft;
                mouseInput.click = true;
                return false;
            });

            canvas.addEventListener("touchend", function(e){
                e.preventDefault();
                mouseInput.click = false;
                return false;
            });

            

            canvas.addEventListener("mouseup", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = false;
                }else if(e.button == 2){
                    mouseInput.altClick = false;
                }
                return false;
            });

            canvas.addEventListener("contextmenu",function(e){
                e.preventDefault();
                e.stopPropagation();
                return false;
            });

            let keys = document.getElementsByClassName('key');
            for(var i = 0; i < keys.length; i++){
                keys[i].addEventListener('touchstart', function(e){
                    let key = this.getAttribute("data-key");
                    keyInputs[key] = true;
                });
                keys[i].addEventListener('touchend', function(e){
                    let key = this.getAttribute("data-key");
                    keyInputs[key] = false;
                });
                keys[i].addEventListener('contextmenu', function(e){
                    e.preventDefault();
                    e.stopPropagation();
                    return false;

                })
            }

            function createStrawb(x,y){
                strawb  = new StrawberrySprite(ctx, textureList.imageList['strawb'], x, y, 0, gridSize, resolution);
                return strawb;
            }
            
            
            textureList.load("img/wall.png", 'wall');
            textureList.load("img/hoof.png", 'hoof');
            textureList.load("img/strawb.png", 'strawb');
            textureList.load("img/deer-face.png", 'face');
            textureList.load("img/deer-face-blink.png", 'face-blink');
            textureList.load("img/deer-face-closed.png", 'face-close');
            textureList.load("img/deer-blush.png", 'face-blush');
            textureList.load("img/flower.png", 'flower');
            textureList.onload(function(){
                console.log("loaded");
                let faceImg = textureList.imageList['face'];
                let faceBlink = textureList.imageList['face-blink'];
                let faceClose = textureList.imageList['face-close'];
                let faceBlush = textureList.imageList['face-blush'];
                let flowerImg = textureList.imageList['flower'];
                let flowerCount = Math.round(Math.random()*20) + 10;
                let strawbCount = Math.round(Math.random()*15) + 5;

                for(var i = 0; i < flowerCount; i++){
                    let thisSpriteX = (Math.round(Math.random() * (ctx.canvas.width - 2*gridSize))) + gridSize;
                    let thisSpriteY = (Math.round(Math.random() * (ctx.canvas.height - 2*gridSize))) + gridSize;
                    spriteList.push(new Sprite(ctx, flowerImg, thisSpriteX, thisSpriteY, 0, gridSize, resolution));
                }

                

                for(var i = 0; i < strawbCount; i++){
                    let thisSpriteX = (Math.round(Math.random() * (ctx.canvas.width - 2*gridSize))) + gridSize;
                    let thisSpriteY = (Math.round(Math.random() * (ctx.canvas.height - 2*gridSize))) + gridSize;
                    spriteList.push(createStrawb(thisSpriteX,thisSpriteY));
                }

                interface = new UserInterface(ctxCamera,  faceImg, faceBlink, faceClose, faceBlush);

                
                play(0);
            });
            

        </script>
    </body>
    <footer>
        
    </footer>
</html>