<!DOCTYPE html>
<html>
    <head>
    </head>
    <body>
        <canvas id="game" width="512" height="512">

        </canvas>
        <canvas id="camera" width="512" height="512">

        </canvas>
        <script>
            const canvasCamera = document.getElementById('camera');
            /** @type {CanvasRenderingContext2D} */
            const ctxCamera = canvasCamera.getContext('2d');

            const canvas = document.getElementById('game');
            /** @type {CanvasRenderingContext2D} */
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "black";
            ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
            var gridSize = 16;
            var resolution = 128;
            var halfRes = 64;
            var keyInputs = {
                w:false,
                s:false,
                a:false,
                d:false,
            };
            var strawb;
            var hoof;
            var player;
            var rayIntersections;
            var spriteRenders = [];

            var mouseInput = {
                x:0,
                y:0,
                click:false,
                altClick:false
            }

            class ImageLoader{
                promiseList = [];
                imageList = {};
                constructor(){

                }

                load(url, name){
                    let imageLoader = this;
                    this.promiseList.push(new Promise(function(resolve,reject){
                        imageLoader.imageList[name] = new Image();
                        imageLoader.imageList[name].onload = function(){return resolve();}
                        imageLoader.imageList[name].onerror = function(){return reject();}
                        imageLoader.imageList[name].src = url;
                    }));
                }

                onload(callback){
                    Promise.all(this.promiseList).then(callback);
                }
            }

            var textureList = new ImageLoader();

            //init grid
            var gridSquares = [];
            for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                gridSquares[i] = [];
                for(var ii = 0; ii < ctx.canvas.height/gridSize; ii++){
                    if(ii == 0 || ii == Math.round(ctx.canvas.height/gridSize - 1) || i == 0 || i == Math.round(ctx.canvas.width/gridSize - 1)){
                        gridSquares[i][ii] = true;
                    }else{
                        gridSquares[i][ii] = false;
                    }
                    
                }
            }

            function drawSquares(ctx, gridSize){
                ctx.save();
                ctx.fillStyle = 'blue';
                for(var i = 0; i < gridSquares.length; i++){
                    for(var ii = 0; ii < gridSquares[i].length; ii++){
                        if(gridSquares[i][ii]){
                            ctx.fillRect(i*gridSize,ii*gridSize,gridSize,gridSize);
                        }
                    }
                }
                ctx.restore();
            }


            

            function generateGrid(gridSize){
                ctx.fillStyle = "black";
                ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                for(var i = 0; i < ctx.canvas.width/gridSize; i++){
                    let lineY = i*gridSize
                    ctx.beginPath();
                    ctx.moveTo(0,lineY);
                    ctx.lineTo(ctx.canvas.width,lineY);
                    ctx.stroke();
                }
                for(var i = 0; i < ctx.canvas.height/gridSize; i++){
                    let lineX = i*gridSize
                    ctx.beginPath();
                    ctx.moveTo(lineX,0)
                    ctx.lineTo(lineX, ctx.canvas.height);
                    ctx.stroke();
                }
            }

            class Hoof{
                isWalking = false;
                isAnimating = false;
                ctx;
                screenX = 150;
                screenY = 160;
                initialY;
                animateSpeed = 0.15;
                topLimit = 20;
                bottomLimit = -20;
                animateMode = 1;
                width = 69;
                height = 240;
                constructor(ctx){
                    this.ctx = ctx;
                    this.screenY = ctx.canvas.height - this.screenY;
                    this.initialY = this.screenY;
                    this.screenX = ctx.canvas.height - this.screenX;
                    this.topLimit += this.screenY;
                    this.bottomLimit += this.screenY;

                }
                animate(deltaT){
                    if(keyInputs.s || keyInputs.w){
                        this.isWalking = true;
                        this.isAnimating = true;
                    }else{
                        this.isWalking = false;
                    }

                    if(this.isAnimating){
                        if(this.animateMode == 1){
                            this.screenY += (this.animateSpeed*deltaT)
                        }else{
                            this.screenY -= (this.animateSpeed*deltaT)
                        }
                        
                        
                        if(this.screenY <= this.bottomLimit){
                            this.animateMode = 1;
                            this.screenY = this.bottomLimit;
                        }else if(this.screenY >= this.topLimit){
                            this.animateMode = 0;
                            this.screenY = this.topLimit;
                        }

                        if((this.screenY <= this.bottomLimit || this.screenY >= this.topLimit || Math.abs(this.screenY - this.initialY) <= 2) && !this.isWalking){
                            this.isAnimating = false;
                        }

                    }
                    
                }

                draw(){
                    this.ctx.drawImage(textureList.imageList['hoof'], Math.round(this.screenX), Math.round(this.screenY), this.width, this.height);
                }

            }

            class Sprite{
                ctx;
                xPos;
                yPos;
                zPos;
                directionX;
                directionY;
                image;
                width;
                distance;

                constructor(ctx, image, xPos, yPos, zPos, width, height){
                    this.ctx = ctx;
                    this.image = image;
                    this.xPos = xPos;
                    this.yPos = yPos;
                    this.zPos = zPos;
                    this.width = width/gridSize;
                    this.height = height;
                }
                draw(player){
                    this.ctx.save();
                    this.ctx.fillStyle = "orange";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.restore();

                    this.ctx.save();
                    let yRelative = (player.yPos - this.yPos)/gridSize;
                    let xRelative = (player.xPos - this.xPos)/gridSize;


                    let gridAngle = Math.atan2(yRelative, xRelative);

                    let playerAngle = Math.atan2(player.directionY, player.directionX);

                    
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    let edgeDistance = Math.sqrt(Math.pow(playerDistance,2) + Math.pow(this.width/2,2));
                    
                    let edgeAngle = Math.atan2(playerDistance, this.width/2);


                    let lineAngle = (gridAngle - Math.PI/2);
                    let linedx = Math.cos(lineAngle);
                    let linedy = Math.sin(lineAngle);
                    
                    let edge1x = this.xPos/gridSize + (linedx*this.width/2);
                    let edge1y = this.yPos/gridSize + (linedy*this.width/2);

                    let edge2x = this.xPos/gridSize - (linedx*this.width/2);
                    let edge2y = this.yPos/gridSize - (linedy*this.width/2);

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "orange";
                    this.ctx.moveTo(edge1x*gridSize, edge1y*gridSize);
                    this.ctx.lineTo(edge2x * gridSize, edge2y * gridSize);
                    this.ctx.stroke();

                    this.ctx.fillStyle = "green";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(edge1x*gridSize), Math.round(edge1y*gridSize), 2, 0, 2*Math.PI);
                    this.ctx.fill();
                    
                    let yRelative2 = (player.yPos/gridSize) - edge1y;
                    let xRelative2 = (player.xPos/gridSize) - edge1x;
                    let edgeAngle1 = Math.atan2(yRelative2, xRelative2);

                    let yRelative3 = (player.yPos/gridSize) - edge2y;
                    let xRelative3 = (player.xPos/gridSize) - edge2x;
                    let edgeAngle2 = Math.atan2(yRelative3, xRelative3);

                    let e1dX = Math.cos(edgeAngle1);
                    let e1dY = Math.sin(edgeAngle1);
                    let e2dX = Math.cos(edgeAngle2);
                    let e2dY = Math.sin(edgeAngle2);

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "green";
                    this.ctx.moveTo(Math.round(edge1x*gridSize), Math.round(edge1y*gridSize));
                    this.ctx.lineTo(Math.round(edge1x*gridSize + (edgeDistance*e1dX*gridSize)), Math.round(edge1y*gridSize + (edgeDistance*e1dY*gridSize)));
                    this.ctx.stroke();

                    this.ctx.strokeStyle = "yellow";
                    this.ctx.moveTo(Math.round(edge2x*gridSize), Math.round(edge2y*gridSize));
                    this.ctx.lineTo(Math.round(edge2x*gridSize + (edgeDistance*e2dX*gridSize)), Math.round(edge2y*gridSize + (edgeDistance*e2dY*gridSize)));
                    this.ctx.stroke();

                    this.ctx.restore();
                }

                isVisible(player, rayIntersections){

                    let yRelative = ( this.yPos - player.yPos)/gridSize;
                    let xRelative = ( this.xPos - player.xPos)/gridSize;


                    let gridAngle = Math.atan2(yRelative, xRelative);

                    let playerAngle = Math.atan2(player.directionY, player.directionX);

                    
                    let playerDistance = Math.sqrt(Math.pow(xRelative, 2) + Math.pow(yRelative, 2));
                    let edgeDistance = Math.sqrt(Math.pow(playerDistance,2) + Math.pow(this.width/2,2));
                    
                    let edgeAngle = Math.atan2(playerDistance, this.width/2);


                    let lineAngle = (gridAngle - Math.PI/2);
                    let linedx = Math.cos(lineAngle);
                    let linedy = Math.sin(lineAngle);
                    
                    let edge1x = this.xPos/gridSize + (linedx*this.width/2);
                    let edge1y = this.yPos/gridSize + (linedy*this.width/2);

                    let edge2x = this.xPos/gridSize - (linedx*this.width/2);
                    let edge2y = this.yPos/gridSize - (linedy*this.width/2);

                    let yRelative2 = (player.yPos/gridSize) - edge1y;
                    let xRelative2 = (player.xPos/gridSize) - edge1x;
                    let edgeAngle1 = Math.atan2(yRelative2, xRelative2);

                    let yRelative3 = (player.yPos/gridSize) - edge2y;
                    let xRelative3 = (player.xPos/gridSize) - edge2x;
                    let edgeAngle2 = Math.atan2(yRelative3, xRelative3);

                    //edges outside the players view cone
                    if(!((edgeAngle1 - Math.PI) >= (playerAngle - Math.PI/4) && (edgeAngle1 - Math.PI) <= (playerAngle + Math.PI/4)) && !((edgeAngle2 - Math.PI) >= (playerAngle - Math.PI/4) && (edgeAngle2 - Math.PI) <= (playerAngle + Math.PI/4))){
                        return false;
                    }

                    
                    for(var i = 0; i < rayIntersections.length; i++){
                        if(rayIntersections[i].distance <= playerDistance){
                            continue;
                        }else{
                            //ray touches sprite
                        
                            var angle1 = edgeAngle1 - Math.PI;
                            var angle2 = edgeAngle2 - Math.PI;

                            if((rayIntersections[i].angle <= angle2 && rayIntersections[i].angle >= angle1)){
                                
                                spriteRenders.push(
                                    {
                                        pixel:i,
                                        distance: playerDistance,
                                        texture: "strawb",
                                        textureCoordinate : Math.abs(Math.floor(64 * ((edgeAngle1 - Math.PI) - rayIntersections[i].angle) / edgeAngle1 - edgeAngle2)),
                                    }
                                )
                            }
                        }
                    }

                }
            }

            class Player{
                ctx;
                xPos;
                yPos;
                speed = 80;
                rSpeed = 200;
                directionX = 0;
                directionY = 0;
                constructor(ctx, xPos, yPos){
                    this.ctx = ctx;
                    this.xPos = xPos;
                    this.yPos = yPos;
                }
                draw(){
                    this.ctx.save()
                    this.ctx.fillStyle = "green";
                    this.ctx.beginPath();
                    this.ctx.arc(Math.round(this.xPos), Math.round(this.yPos), 4, 0, 2*Math.PI);
                    this.ctx.fill();
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = "yellow";
                    this.ctx.lineWidth = 4;
                    this.ctx.moveTo(this.xPos, this.yPos);
                    this.ctx.lineTo(this.xPos + this.directionX*10, this.yPos + this.directionY*10);
                    this.ctx.stroke();
                    this.ctx.restore();
                }
                animate(deltaT){

                    let dy = 0;
                    let dx = 0;
                    if(keyInputs.w){
                        dy -= this.speed * deltaT/1000;
                    }
                    if(keyInputs.s){
                        dy += this.speed * deltaT/1000;
                    }

                    
                    if(keyInputs.a){
                        dx -= this.rSpeed * deltaT/1000;
                    }
                    if(keyInputs.d){
                        dx += this.rSpeed * deltaT/1000;
                    }

                    if(dx != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        let newAngle = viewAngle + ( dx * 0.0174533);
                        this.directionY = Math.sin(newAngle);
                        this.directionX = Math.cos(newAngle);
                    }

                    if(dy != 0){
                        let viewAngle = Math.atan2(this.directionY, this.directionX);
                        let nextY = this.yPos - Math.sin(viewAngle)*dy;
                        let nextX = this.xPos - Math.cos(viewAngle)*dy;

                        let nextGridY = Math.floor(nextY/gridSize);
                        let nextGridX = Math.floor(nextX/gridSize);

                        if(gridSquares[nextGridX] && !gridSquares[nextGridX][nextGridY]){
                            this.yPos = nextY;
                            this.xPos = nextX;
                        }

                        this.yPos = Math.max(this.yPos, 0);
                        this.yPos = Math.min(this.yPos, ctx.canvas.height);

                        this.xPos = Math.max(this.xPos, 0);
                        this.xPos = Math.min(this.xPos, ctx.canvas.width);
                    }
                }
            }

            hoof = new Hoof(ctxCamera);

            player = new Player(ctx, 256, 256);
            rayIntersections = [

            ];

            function drawMouse(ctx){
                ctx.save()
                ctx.fillStyle = "red";
                ctx.beginPath();
                ctx.arc(Math.round(mouseInput.x), Math.round(mouseInput.y), 4, 0, 2*Math.PI);
                ctx.fill();
                ctx.restore();
            }

            function paintSquares(mouseInput, gridSize){
                if(mouseInput.click || mouseInput.altClick){
                    let gridX = Math.floor(mouseInput.x/gridSize);
                    let gridY = Math.floor(mouseInput.y/gridSize);
                    if(gridX < gridSquares.length){
                        if(gridY < gridSquares[gridX].length){
                            if(mouseInput.click){
                                gridSquares[gridX][gridY] = true;
                            }else if(mouseInput.altClick){
                                gridSquares[gridX][gridY] = false;
                            }
                        }
                    }
                }
            }

            function drawCamera(ctxCamera, rayIntersections){
                ctxCamera.save();
                ctxCamera.fillStyle = "grey";
                ctxCamera.fillRect(0,0,ctxCamera.canvas.width,ctxCamera.canvas.height/2);
                ctxCamera.fillStyle = "#7ca666";
                ctxCamera.fillRect(0,ctxCamera.canvas.height/2,ctxCamera.canvas.width,ctxCamera.canvas.height/2);
                //draw walls
                for(var i = 0; i < resolution; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(rayIntersections[i] && rayIntersections[i].intersects){
                        let height =  256 * (1/rayIntersections[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;
                        ctxCamera.drawImage(textureList.imageList[rayIntersections[i].texture], rayIntersections[i].textureCoordinate, 0, 1, textureList.imageList[rayIntersections[i].texture].height, i*width, yOffset, width, height)
                    }
                }

                for(var i = 0; i < spriteRenders.length; i++){
                    let width = Math.floor(ctxCamera.canvas.width/resolution);
                    if(spriteRenders[i]){
                        let height =  256 * (1/spriteRenders[i].distance);
                        let yOffset = (ctxCamera.canvas.height - height)/2;
                        ctxCamera.drawImage(textureList.imageList[spriteRenders[i].texture], spriteRenders[i].textureCoordinate, 0, 1, textureList.imageList[spriteRenders[i].texture].height, spriteRenders[i].pixel*width, yOffset, width, height)
                        ctxCamera.fillStyle = "red";
                        ctxCamera.fillRect(spriteRenders[i].pixel*width, yOffset, width, height)
                    }
                }
                

                ctxCamera.restore();
            }



            function play(deltaT){
                var frameStart = performance.now();
                spriteRenders = [];
                generateGrid(gridSize);
                paintSquares(mouseInput, gridSize);
                drawSquares(ctx, gridSize);
                drawMouse(ctx);
                player.animate(deltaT);
                player.draw();
                rayCastView(ctx, player);
                strawb.draw(player);
                strawb.isVisible(player, rayIntersections);
                drawCamera(ctxCamera, rayIntersections);
                hoof.animate(deltaT);
                hoof.draw();
                

                window.requestAnimationFrame(function(){
                    play(performance.now() - frameStart);
                });
            }


            //check for intersections with walls
            //start and end in grid space
            function castRay(viewAngle, startCellX, startCellY){
                let dx = Math.cos(viewAngle);
                let dy = Math.sin(viewAngle);

                let xRay = 0;
                let yRay = 0;

                //scaling factor step size
                let sx =  Math.sqrt(1 + Math.pow(dy/dx,2));
                let sy = Math.sqrt(1 + Math.pow(dx/dy,2));

                let tileCheckX = Math.floor(startCellX);
                let tileCheckY = Math.floor(startCellY);

                //step directions
                let xStep;
                if(dx < 0){
                    xStep = -1;
                    xRay = (startCellX - tileCheckX) * sx;
                }else{
                    xStep = 1;
                    xRay = (tileCheckX + 1 - startCellX) * sx;
                }
                
                let yStep;
                if(dy < 0){
                    yStep = -1;
                    yRay = (startCellY - tileCheckY) * sy;
                }else{
                    yStep = 1;
                    yRay = (tileCheckY + 1 - startCellY) * sy;
                }

                let tileFound = false;
                let rayLength = 0;
                let side;
                while(!tileFound && rayLength < 512){
                    if(xRay < yRay){
                        tileCheckX += xStep;
                        rayLength = xRay;
                        xRay += sx;
                        side = "x";
                    }else{
                        tileCheckY += yStep;
                        rayLength = yRay;
                        yRay += sy;
                        side = "y";
                    }

                    if(tileCheckX >= 0 &&  tileCheckY >= 0 && tileCheckX < gridSquares.length && tileCheckY < gridSquares[tileCheckX].length){
                        if(gridSquares[tileCheckX][tileCheckY]){
                            tileFound = true;
                        }
                    }
                }

                return {
                    tileFound:tileFound,
                    dx:dx,
                    dy:dy,
                    rayLength:rayLength,
                    side:side
                }
            }

            function rayCastView(ctx, player){

                //start and end points in grid space
                let startCellX = player.xPos/gridSize;
                let startCellY = player.yPos/gridSize;

                //unit vector
                let dx = player.directionX;
                let dy = player.directionY;
                let viewAngle = Math.atan2(dy, dx);
                
                for(var i = -1 * halfRes; i < halfRes; i++){
                    let offset = (Math.PI/2)/resolution;
                    let newAngle = viewAngle + offset*i;
                    let intersect = castRay(newAngle, startCellX, startCellY);

                    if(intersect.tileFound){
                        let intersectionX = startCellX + (intersect.dx * intersect.rayLength);
                        let intersectionY = startCellY + (intersect.dy * intersect.rayLength);
                        ctx.save()
                        ctx.fillStyle = "yellow";
                        ctx.beginPath();
                        ctx.arc(Math.round(intersectionX*gridSize), Math.round(intersectionY*gridSize), 4, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.restore();

                        let textureCoordinate;
                        if(intersect.side == "y"){
                            textureCoordinate = Math.floor(32*(intersectionX - Math.floor(intersectionX)));
                        }else{
                            textureCoordinate = Math.floor(32*(intersectionY - Math.floor(intersectionY)));
                        }
                        
                        rayIntersections[i+halfRes] = {
                            distance:intersect.rayLength,
                            side:intersect.side,
                            angle: newAngle,
                            intersects:true,
                            x:intersectionX,
                            y:intersectionY,
                            textureCoordinate:textureCoordinate,
                            texture:"wall"
                        }
                    }else{
                        rayIntersections[i+halfRes] = {
                            distance:Infinity,
                            side:"",
                            angle:newAngle,
                            intersects:false,
                            x:0,
                            y:0,
                            textureCoordinate:0,
                            texture:""
                        }
                    }
                }
                
            }

            
            document.addEventListener("keydown",function(e){
                keyInputs[e.key] = true;
            });

            document.addEventListener("keyup",function(e){
                keyInputs[e.key] = false;
            });

            canvas.addEventListener("mousemove",function(e){
                mouseInput.x = e.offsetX;
                mouseInput.y = e.offsetY;
            });

            canvas.addEventListener("mousedown", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = true;
                }else if(e.button == 2){
                    mouseInput.altClick = true;
                }
                return false;
            });

            canvas.addEventListener("mouseup", function(e){
                e.preventDefault();
                if(e.button == 0){
                    mouseInput.click = false;
                }else if(e.button == 2){
                    mouseInput.altClick = false;
                }
                return false;
            });

            canvas.addEventListener("contextmenu",function(e){
                e.preventDefault();
                return false;
            })
            
            textureList.load("img/wall.png", 'wall');
            textureList.load("img/hoof.png", 'hoof');
            textureList.load("img/strawb.png", 'strawb');
            textureList.onload(function(){
                console.log("loaded");

                strawb  = new Sprite(ctx, textureList['strawb'], 50, 50, 0, gridSize, resolution);
                
                play(0);
            });
            

        </script>
    </body>
    <footer>
        
    </footer>
</html>